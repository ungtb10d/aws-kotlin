// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.ec2.model

import aws.smithy.kotlin.runtime.time.Instant

/**
 * Contains the output of GetReservedInstancesExchangeQuote.
 */
public class GetReservedInstancesExchangeQuoteResponse private constructor(builder: Builder) {
    /**
     * The currency of the transaction.
     */
    public val currencyCode: kotlin.String? = builder.currencyCode
    /**
     * If `true`, the exchange is valid. If `false`, the exchange cannot be completed.
     */
    public val isValidExchange: kotlin.Boolean? = builder.isValidExchange
    /**
     * The new end date of the reservation term.
     */
    public val outputReservedInstancesWillExpireAt: aws.smithy.kotlin.runtime.time.Instant? = builder.outputReservedInstancesWillExpireAt
    /**
     * The total true upfront charge for the exchange.
     */
    public val paymentDue: kotlin.String? = builder.paymentDue
    /**
     * The cost associated with the Reserved Instance.
     */
    public val reservedInstanceValueRollup: aws.sdk.kotlin.services.ec2.model.ReservationValue? = builder.reservedInstanceValueRollup
    /**
     * The configuration of your Convertible Reserved Instances.
     */
    public val reservedInstanceValueSet: List<ReservedInstanceReservationValue>? = builder.reservedInstanceValueSet
    /**
     * The cost associated with the Reserved Instance.
     */
    public val targetConfigurationValueRollup: aws.sdk.kotlin.services.ec2.model.ReservationValue? = builder.targetConfigurationValueRollup
    /**
     * The values of the target Convertible Reserved Instances.
     */
    public val targetConfigurationValueSet: List<TargetReservationValue>? = builder.targetConfigurationValueSet
    /**
     * Describes the reason why the exchange cannot be completed.
     */
    public val validationFailureReason: kotlin.String? = builder.validationFailureReason

    public companion object {
        public operator fun invoke(block: Builder.() -> kotlin.Unit): aws.sdk.kotlin.services.ec2.model.GetReservedInstancesExchangeQuoteResponse = Builder().apply(block).build()
    }

    override fun toString(): kotlin.String = buildString {
        append("GetReservedInstancesExchangeQuoteResponse(")
        append("currencyCode=$currencyCode,")
        append("isValidExchange=$isValidExchange,")
        append("outputReservedInstancesWillExpireAt=$outputReservedInstancesWillExpireAt,")
        append("paymentDue=$paymentDue,")
        append("reservedInstanceValueRollup=$reservedInstanceValueRollup,")
        append("reservedInstanceValueSet=$reservedInstanceValueSet,")
        append("targetConfigurationValueRollup=$targetConfigurationValueRollup,")
        append("targetConfigurationValueSet=$targetConfigurationValueSet,")
        append("validationFailureReason=$validationFailureReason)")
    }

    override fun hashCode(): kotlin.Int {
        var result = currencyCode?.hashCode() ?: 0
        result = 31 * result + (isValidExchange?.hashCode() ?: 0)
        result = 31 * result + (outputReservedInstancesWillExpireAt?.hashCode() ?: 0)
        result = 31 * result + (paymentDue?.hashCode() ?: 0)
        result = 31 * result + (reservedInstanceValueRollup?.hashCode() ?: 0)
        result = 31 * result + (reservedInstanceValueSet?.hashCode() ?: 0)
        result = 31 * result + (targetConfigurationValueRollup?.hashCode() ?: 0)
        result = 31 * result + (targetConfigurationValueSet?.hashCode() ?: 0)
        result = 31 * result + (validationFailureReason?.hashCode() ?: 0)
        return result
    }

    override fun equals(other: kotlin.Any?): kotlin.Boolean {
        if (this === other) return true
        if (other == null || this::class != other::class) return false

        other as GetReservedInstancesExchangeQuoteResponse

        if (currencyCode != other.currencyCode) return false
        if (isValidExchange != other.isValidExchange) return false
        if (outputReservedInstancesWillExpireAt != other.outputReservedInstancesWillExpireAt) return false
        if (paymentDue != other.paymentDue) return false
        if (reservedInstanceValueRollup != other.reservedInstanceValueRollup) return false
        if (reservedInstanceValueSet != other.reservedInstanceValueSet) return false
        if (targetConfigurationValueRollup != other.targetConfigurationValueRollup) return false
        if (targetConfigurationValueSet != other.targetConfigurationValueSet) return false
        if (validationFailureReason != other.validationFailureReason) return false

        return true
    }

    public inline fun copy(block: Builder.() -> kotlin.Unit = {}): aws.sdk.kotlin.services.ec2.model.GetReservedInstancesExchangeQuoteResponse = Builder(this).apply(block).build()

    public class Builder {
        /**
         * The currency of the transaction.
         */
        public var currencyCode: kotlin.String? = null
        /**
         * If `true`, the exchange is valid. If `false`, the exchange cannot be completed.
         */
        public var isValidExchange: kotlin.Boolean? = null
        /**
         * The new end date of the reservation term.
         */
        public var outputReservedInstancesWillExpireAt: aws.smithy.kotlin.runtime.time.Instant? = null
        /**
         * The total true upfront charge for the exchange.
         */
        public var paymentDue: kotlin.String? = null
        /**
         * The cost associated with the Reserved Instance.
         */
        public var reservedInstanceValueRollup: aws.sdk.kotlin.services.ec2.model.ReservationValue? = null
        /**
         * The configuration of your Convertible Reserved Instances.
         */
        public var reservedInstanceValueSet: List<ReservedInstanceReservationValue>? = null
        /**
         * The cost associated with the Reserved Instance.
         */
        public var targetConfigurationValueRollup: aws.sdk.kotlin.services.ec2.model.ReservationValue? = null
        /**
         * The values of the target Convertible Reserved Instances.
         */
        public var targetConfigurationValueSet: List<TargetReservationValue>? = null
        /**
         * Describes the reason why the exchange cannot be completed.
         */
        public var validationFailureReason: kotlin.String? = null

        @PublishedApi
        internal constructor()
        @PublishedApi
        internal constructor(x: aws.sdk.kotlin.services.ec2.model.GetReservedInstancesExchangeQuoteResponse) : this() {
            this.currencyCode = x.currencyCode
            this.isValidExchange = x.isValidExchange
            this.outputReservedInstancesWillExpireAt = x.outputReservedInstancesWillExpireAt
            this.paymentDue = x.paymentDue
            this.reservedInstanceValueRollup = x.reservedInstanceValueRollup
            this.reservedInstanceValueSet = x.reservedInstanceValueSet
            this.targetConfigurationValueRollup = x.targetConfigurationValueRollup
            this.targetConfigurationValueSet = x.targetConfigurationValueSet
            this.validationFailureReason = x.validationFailureReason
        }

        @PublishedApi
        internal fun build(): aws.sdk.kotlin.services.ec2.model.GetReservedInstancesExchangeQuoteResponse = GetReservedInstancesExchangeQuoteResponse(this)

        /**
         * construct an [aws.sdk.kotlin.services.ec2.model.ReservationValue] inside the given [block]
         */
        public fun reservedInstanceValueRollup(block: aws.sdk.kotlin.services.ec2.model.ReservationValue.Builder.() -> kotlin.Unit) {
            this.reservedInstanceValueRollup = aws.sdk.kotlin.services.ec2.model.ReservationValue.invoke(block)
        }

        /**
         * construct an [aws.sdk.kotlin.services.ec2.model.ReservationValue] inside the given [block]
         */
        public fun targetConfigurationValueRollup(block: aws.sdk.kotlin.services.ec2.model.ReservationValue.Builder.() -> kotlin.Unit) {
            this.targetConfigurationValueRollup = aws.sdk.kotlin.services.ec2.model.ReservationValue.invoke(block)
        }
    }
}
