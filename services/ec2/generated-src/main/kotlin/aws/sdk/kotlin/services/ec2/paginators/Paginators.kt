// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.ec2.paginators

import aws.sdk.kotlin.services.ec2.Ec2Client
import aws.sdk.kotlin.services.ec2.model.AddressAttribute
import aws.sdk.kotlin.services.ec2.model.AllowedPrincipal
import aws.sdk.kotlin.services.ec2.model.AuthorizationRule
import aws.sdk.kotlin.services.ec2.model.ByoipCidr
import aws.sdk.kotlin.services.ec2.model.CapacityReservation
import aws.sdk.kotlin.services.ec2.model.CapacityReservationFleet
import aws.sdk.kotlin.services.ec2.model.CapacityReservationGroup
import aws.sdk.kotlin.services.ec2.model.CarrierGateway
import aws.sdk.kotlin.services.ec2.model.ClassicLinkDnsSupport
import aws.sdk.kotlin.services.ec2.model.ClassicLinkInstance
import aws.sdk.kotlin.services.ec2.model.ClientVpnConnection
import aws.sdk.kotlin.services.ec2.model.ClientVpnEndpoint
import aws.sdk.kotlin.services.ec2.model.ClientVpnRoute
import aws.sdk.kotlin.services.ec2.model.CoipPool
import aws.sdk.kotlin.services.ec2.model.ConnectionNotification
import aws.sdk.kotlin.services.ec2.model.DescribeAddressesAttributeRequest
import aws.sdk.kotlin.services.ec2.model.DescribeAddressesAttributeResponse
import aws.sdk.kotlin.services.ec2.model.DescribeByoipCidrsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeByoipCidrsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationFleetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationFleetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCarrierGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCarrierGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClassicLinkInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClassicLinkInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnAuthorizationRulesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnAuthorizationRulesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnEndpointsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnEndpointsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnRoutesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnRoutesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnTargetNetworksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnTargetNetworksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCoipPoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCoipPoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeDhcpOptionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeDhcpOptionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeEgressOnlyInternetGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeEgressOnlyInternetGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeExportImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeExportImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesSuccessItem
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoreSuccessItem
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoresRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoresResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFleetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFleetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFlowLogsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFlowLogsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFpgaImagesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFpgaImagesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIamInstanceProfileAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIamInstanceProfileAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeImportImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeImportImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeImportSnapshotTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeImportSnapshotTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceCreditSpecificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceCreditSpecificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceEventWindowsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceEventWindowsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypeOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypeOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInternetGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInternetGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamPoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamPoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamScopesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamScopesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpv6PoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpv6PoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplateVersionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplateVersionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplatesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplatesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVpcAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVpcAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfaceGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfaceGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfacesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfacesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeManagedPrefixListsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeManagedPrefixListsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeMovingAddressesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeMovingAddressesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNatGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNatGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkAclsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkAclsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopeAnalysesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopeAnalysesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAnalysesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAnalysesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsPathsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsPathsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacePermissionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacePermissionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacesResponse
import aws.sdk.kotlin.services.ec2.model.DescribePrefixListsRequest
import aws.sdk.kotlin.services.ec2.model.DescribePrefixListsResponse
import aws.sdk.kotlin.services.ec2.model.DescribePrincipalIdFormatRequest
import aws.sdk.kotlin.services.ec2.model.DescribePrincipalIdFormatResponse
import aws.sdk.kotlin.services.ec2.model.DescribePublicIpv4PoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribePublicIpv4PoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReplaceRootVolumeTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReplaceRootVolumeTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesModificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesModificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstanceAvailabilityRequest
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstanceAvailabilityResponse
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupRulesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupRulesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotTierStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotTierStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotFleetRequestsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotFleetRequestsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotInstanceRequestsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotInstanceRequestsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotPriceHistoryRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotPriceHistoryResponse
import aws.sdk.kotlin.services.ec2.model.DescribeStaleSecurityGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeStaleSecurityGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeStoreImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeStoreImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSubnetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSubnetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTagsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTagsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorFiltersRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorFiltersResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorSessionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorSessionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorTargetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorTargetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectPeersRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectPeersResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayMulticastDomainsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayMulticastDomainsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPeeringAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPeeringAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayVpcAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayVpcAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrunkInterfaceAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrunkInterfaceAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumeStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumeStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesModificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesModificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcClassicLinkDnsSupportRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcClassicLinkDnsSupportResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionNotificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionNotificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServiceConfigurationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServiceConfigurationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServicePermissionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServicePermissionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcPeeringConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcPeeringConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcsResponse
import aws.sdk.kotlin.services.ec2.model.DhcpOptions
import aws.sdk.kotlin.services.ec2.model.EgressOnlyInternetGateway
import aws.sdk.kotlin.services.ec2.model.ExportImageTask
import aws.sdk.kotlin.services.ec2.model.FleetData
import aws.sdk.kotlin.services.ec2.model.FlowLog
import aws.sdk.kotlin.services.ec2.model.FpgaImage
import aws.sdk.kotlin.services.ec2.model.GetAssociatedIpv6PoolCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetAssociatedIpv6PoolCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetGroupsForCapacityReservationRequest
import aws.sdk.kotlin.services.ec2.model.GetGroupsForCapacityReservationResponse
import aws.sdk.kotlin.services.ec2.model.GetInstanceTypesFromInstanceRequirementsRequest
import aws.sdk.kotlin.services.ec2.model.GetInstanceTypesFromInstanceRequirementsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamAddressHistoryRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamAddressHistoryResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolAllocationsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolAllocationsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamResourceCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamResourceCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListEntriesRequest
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListEntriesResponse
import aws.sdk.kotlin.services.ec2.model.GetSpotPlacementScoresRequest
import aws.sdk.kotlin.services.ec2.model.GetSpotPlacementScoresResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayAttachmentPropagationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayAttachmentPropagationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayMulticastDomainAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayMulticastDomainAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPrefixListReferencesRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPrefixListReferencesResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTableAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTableAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTablePropagationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTablePropagationsResponse
import aws.sdk.kotlin.services.ec2.model.GetVpnConnectionDeviceTypesRequest
import aws.sdk.kotlin.services.ec2.model.GetVpnConnectionDeviceTypesResponse
import aws.sdk.kotlin.services.ec2.model.Host
import aws.sdk.kotlin.services.ec2.model.HostOffering
import aws.sdk.kotlin.services.ec2.model.HostReservation
import aws.sdk.kotlin.services.ec2.model.IamInstanceProfileAssociation
import aws.sdk.kotlin.services.ec2.model.ImportImageTask
import aws.sdk.kotlin.services.ec2.model.ImportSnapshotTask
import aws.sdk.kotlin.services.ec2.model.InstanceCreditSpecification
import aws.sdk.kotlin.services.ec2.model.InstanceEventWindow
import aws.sdk.kotlin.services.ec2.model.InstanceStatus
import aws.sdk.kotlin.services.ec2.model.InstanceTypeInfo
import aws.sdk.kotlin.services.ec2.model.InstanceTypeInfoFromInstanceRequirements
import aws.sdk.kotlin.services.ec2.model.InstanceTypeOffering
import aws.sdk.kotlin.services.ec2.model.InternetGateway
import aws.sdk.kotlin.services.ec2.model.Ipam
import aws.sdk.kotlin.services.ec2.model.IpamAddressHistoryRecord
import aws.sdk.kotlin.services.ec2.model.IpamPool
import aws.sdk.kotlin.services.ec2.model.IpamPoolAllocation
import aws.sdk.kotlin.services.ec2.model.IpamPoolCidr
import aws.sdk.kotlin.services.ec2.model.IpamResourceCidr
import aws.sdk.kotlin.services.ec2.model.IpamScope
import aws.sdk.kotlin.services.ec2.model.Ipv6CidrAssociation
import aws.sdk.kotlin.services.ec2.model.Ipv6Pool
import aws.sdk.kotlin.services.ec2.model.LaunchTemplate
import aws.sdk.kotlin.services.ec2.model.LaunchTemplateVersion
import aws.sdk.kotlin.services.ec2.model.ListSnapshotsInRecycleBinRequest
import aws.sdk.kotlin.services.ec2.model.ListSnapshotsInRecycleBinResponse
import aws.sdk.kotlin.services.ec2.model.LocalGateway
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRoute
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTable
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTableVirtualInterfaceGroupAssociation
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTableVpcAssociation
import aws.sdk.kotlin.services.ec2.model.LocalGatewayVirtualInterface
import aws.sdk.kotlin.services.ec2.model.LocalGatewayVirtualInterfaceGroup
import aws.sdk.kotlin.services.ec2.model.ManagedPrefixList
import aws.sdk.kotlin.services.ec2.model.MovingAddressStatus
import aws.sdk.kotlin.services.ec2.model.NatGateway
import aws.sdk.kotlin.services.ec2.model.NetworkAcl
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAccessScope
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAccessScopeAnalysis
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAnalysis
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsPath
import aws.sdk.kotlin.services.ec2.model.NetworkInterface
import aws.sdk.kotlin.services.ec2.model.NetworkInterfacePermission
import aws.sdk.kotlin.services.ec2.model.PrefixList
import aws.sdk.kotlin.services.ec2.model.PrefixListAssociation
import aws.sdk.kotlin.services.ec2.model.PrefixListEntry
import aws.sdk.kotlin.services.ec2.model.PrincipalIdFormat
import aws.sdk.kotlin.services.ec2.model.PublicIpv4Pool
import aws.sdk.kotlin.services.ec2.model.ReplaceRootVolumeTask
import aws.sdk.kotlin.services.ec2.model.Reservation
import aws.sdk.kotlin.services.ec2.model.ReservedInstancesModification
import aws.sdk.kotlin.services.ec2.model.ReservedInstancesOffering
import aws.sdk.kotlin.services.ec2.model.RouteTable
import aws.sdk.kotlin.services.ec2.model.ScheduledInstance
import aws.sdk.kotlin.services.ec2.model.ScheduledInstanceAvailability
import aws.sdk.kotlin.services.ec2.model.SearchLocalGatewayRoutesRequest
import aws.sdk.kotlin.services.ec2.model.SearchLocalGatewayRoutesResponse
import aws.sdk.kotlin.services.ec2.model.SearchTransitGatewayMulticastGroupsRequest
import aws.sdk.kotlin.services.ec2.model.SearchTransitGatewayMulticastGroupsResponse
import aws.sdk.kotlin.services.ec2.model.SecurityGroup
import aws.sdk.kotlin.services.ec2.model.SecurityGroupRule
import aws.sdk.kotlin.services.ec2.model.ServiceConfiguration
import aws.sdk.kotlin.services.ec2.model.Snapshot
import aws.sdk.kotlin.services.ec2.model.SnapshotRecycleBinInfo
import aws.sdk.kotlin.services.ec2.model.SnapshotTierStatus
import aws.sdk.kotlin.services.ec2.model.SpotFleetRequestConfig
import aws.sdk.kotlin.services.ec2.model.SpotInstanceRequest
import aws.sdk.kotlin.services.ec2.model.SpotPlacementScore
import aws.sdk.kotlin.services.ec2.model.SpotPrice
import aws.sdk.kotlin.services.ec2.model.StaleSecurityGroup
import aws.sdk.kotlin.services.ec2.model.StoreImageTaskResult
import aws.sdk.kotlin.services.ec2.model.Subnet
import aws.sdk.kotlin.services.ec2.model.TagDescription
import aws.sdk.kotlin.services.ec2.model.TargetNetwork
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorFilter
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorSession
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorTarget
import aws.sdk.kotlin.services.ec2.model.TransitGateway
import aws.sdk.kotlin.services.ec2.model.TransitGatewayAttachment
import aws.sdk.kotlin.services.ec2.model.TransitGatewayAttachmentPropagation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayConnect
import aws.sdk.kotlin.services.ec2.model.TransitGatewayConnectPeer
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastDomain
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastDomainAssociation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastGroup
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPeeringAttachment
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPrefixListReference
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTable
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTableAssociation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTablePropagation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayVpcAttachment
import aws.sdk.kotlin.services.ec2.model.TrunkInterfaceAssociation
import aws.sdk.kotlin.services.ec2.model.Volume
import aws.sdk.kotlin.services.ec2.model.VolumeModification
import aws.sdk.kotlin.services.ec2.model.VolumeStatusItem
import aws.sdk.kotlin.services.ec2.model.Vpc
import aws.sdk.kotlin.services.ec2.model.VpcEndpoint
import aws.sdk.kotlin.services.ec2.model.VpcEndpointConnection
import aws.sdk.kotlin.services.ec2.model.VpcPeeringConnection
import aws.sdk.kotlin.services.ec2.model.VpnConnectionDeviceType
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.transform


/**
 * Paginate over [DescribeAddressesAttributeResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeAddressesAttributeRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeAddressesAttributeResponse]
 */
fun Ec2Client.describeAddressesAttributePaginated(initialRequest: DescribeAddressesAttributeRequest): Flow<DescribeAddressesAttributeResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeAddressesAttributePaginated.describeAddressesAttribute(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeAddressesAttributePaginated]
 * to access the nested member [AddressAttribute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AddressAttribute]
 */
@JvmName("describeAddressesAttributeResponseAddressAttribute")
fun Flow<DescribeAddressesAttributeResponse>.addresses(): Flow<AddressAttribute> =
    transform() { response ->
        response.addresses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeByoipCidrsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeByoipCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeByoipCidrsResponse]
 */
fun Ec2Client.describeByoipCidrsPaginated(initialRequest: DescribeByoipCidrsRequest): Flow<DescribeByoipCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeByoipCidrsPaginated.describeByoipCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeByoipCidrsPaginated]
 * to access the nested member [ByoipCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ByoipCidr]
 */
@JvmName("describeByoipCidrsResponseByoipCidr")
fun Flow<DescribeByoipCidrsResponse>.byoipCidrs(): Flow<ByoipCidr> =
    transform() { response ->
        response.byoipCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationFleetsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeCapacityReservationFleetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationFleetsResponse]
 */
fun Ec2Client.describeCapacityReservationFleetsPaginated(initialRequest: DescribeCapacityReservationFleetsRequest): Flow<DescribeCapacityReservationFleetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCapacityReservationFleetsPaginated.describeCapacityReservationFleets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeCapacityReservationFleetsPaginated]
 * to access the nested member [CapacityReservationFleet]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservationFleet]
 */
@JvmName("describeCapacityReservationFleetsResponseCapacityReservationFleet")
fun Flow<DescribeCapacityReservationFleetsResponse>.capacityReservationFleets(): Flow<CapacityReservationFleet> =
    transform() { response ->
        response.capacityReservationFleets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeCapacityReservationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationsResponse]
 */
fun Ec2Client.describeCapacityReservationsPaginated(initialRequest: DescribeCapacityReservationsRequest): Flow<DescribeCapacityReservationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCapacityReservationsPaginated.describeCapacityReservations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeCapacityReservationsPaginated]
 * to access the nested member [CapacityReservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservation]
 */
@JvmName("describeCapacityReservationsResponseCapacityReservation")
fun Flow<DescribeCapacityReservationsResponse>.capacityReservations(): Flow<CapacityReservation> =
    transform() { response ->
        response.capacityReservations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCarrierGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeCarrierGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCarrierGatewaysResponse]
 */
fun Ec2Client.describeCarrierGatewaysPaginated(initialRequest: DescribeCarrierGatewaysRequest): Flow<DescribeCarrierGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCarrierGatewaysPaginated.describeCarrierGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeCarrierGatewaysPaginated]
 * to access the nested member [CarrierGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CarrierGateway]
 */
@JvmName("describeCarrierGatewaysResponseCarrierGateway")
fun Flow<DescribeCarrierGatewaysResponse>.carrierGateways(): Flow<CarrierGateway> =
    transform() { response ->
        response.carrierGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClassicLinkInstancesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClassicLinkInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClassicLinkInstancesResponse]
 */
fun Ec2Client.describeClassicLinkInstancesPaginated(initialRequest: DescribeClassicLinkInstancesRequest): Flow<DescribeClassicLinkInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClassicLinkInstancesPaginated.describeClassicLinkInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClassicLinkInstancesPaginated]
 * to access the nested member [ClassicLinkInstance]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClassicLinkInstance]
 */
@JvmName("describeClassicLinkInstancesResponseClassicLinkInstance")
fun Flow<DescribeClassicLinkInstancesResponse>.instances(): Flow<ClassicLinkInstance> =
    transform() { response ->
        response.instances?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnAuthorizationRulesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClientVpnAuthorizationRulesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnAuthorizationRulesResponse]
 */
fun Ec2Client.describeClientVpnAuthorizationRulesPaginated(initialRequest: DescribeClientVpnAuthorizationRulesRequest): Flow<DescribeClientVpnAuthorizationRulesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnAuthorizationRulesPaginated.describeClientVpnAuthorizationRules(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClientVpnAuthorizationRulesPaginated]
 * to access the nested member [AuthorizationRule]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AuthorizationRule]
 */
@JvmName("describeClientVpnAuthorizationRulesResponseAuthorizationRule")
fun Flow<DescribeClientVpnAuthorizationRulesResponse>.authorizationRules(): Flow<AuthorizationRule> =
    transform() { response ->
        response.authorizationRules?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnConnectionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClientVpnConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnConnectionsResponse]
 */
fun Ec2Client.describeClientVpnConnectionsPaginated(initialRequest: DescribeClientVpnConnectionsRequest): Flow<DescribeClientVpnConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnConnectionsPaginated.describeClientVpnConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClientVpnConnectionsPaginated]
 * to access the nested member [ClientVpnConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnConnection]
 */
@JvmName("describeClientVpnConnectionsResponseClientVpnConnection")
fun Flow<DescribeClientVpnConnectionsResponse>.connections(): Flow<ClientVpnConnection> =
    transform() { response ->
        response.connections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnEndpointsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClientVpnEndpointsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnEndpointsResponse]
 */
fun Ec2Client.describeClientVpnEndpointsPaginated(initialRequest: DescribeClientVpnEndpointsRequest): Flow<DescribeClientVpnEndpointsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnEndpointsPaginated.describeClientVpnEndpoints(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClientVpnEndpointsPaginated]
 * to access the nested member [ClientVpnEndpoint]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnEndpoint]
 */
@JvmName("describeClientVpnEndpointsResponseClientVpnEndpoint")
fun Flow<DescribeClientVpnEndpointsResponse>.clientVpnEndpoints(): Flow<ClientVpnEndpoint> =
    transform() { response ->
        response.clientVpnEndpoints?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnRoutesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClientVpnRoutesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnRoutesResponse]
 */
fun Ec2Client.describeClientVpnRoutesPaginated(initialRequest: DescribeClientVpnRoutesRequest): Flow<DescribeClientVpnRoutesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnRoutesPaginated.describeClientVpnRoutes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClientVpnRoutesPaginated]
 * to access the nested member [ClientVpnRoute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnRoute]
 */
@JvmName("describeClientVpnRoutesResponseClientVpnRoute")
fun Flow<DescribeClientVpnRoutesResponse>.routes(): Flow<ClientVpnRoute> =
    transform() { response ->
        response.routes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnTargetNetworksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeClientVpnTargetNetworksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnTargetNetworksResponse]
 */
fun Ec2Client.describeClientVpnTargetNetworksPaginated(initialRequest: DescribeClientVpnTargetNetworksRequest): Flow<DescribeClientVpnTargetNetworksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnTargetNetworksPaginated.describeClientVpnTargetNetworks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeClientVpnTargetNetworksPaginated]
 * to access the nested member [TargetNetwork]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TargetNetwork]
 */
@JvmName("describeClientVpnTargetNetworksResponseTargetNetwork")
fun Flow<DescribeClientVpnTargetNetworksResponse>.clientVpnTargetNetworks(): Flow<TargetNetwork> =
    transform() { response ->
        response.clientVpnTargetNetworks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCoipPoolsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeCoipPoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCoipPoolsResponse]
 */
fun Ec2Client.describeCoipPoolsPaginated(initialRequest: DescribeCoipPoolsRequest): Flow<DescribeCoipPoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCoipPoolsPaginated.describeCoipPools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeCoipPoolsPaginated]
 * to access the nested member [CoipPool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CoipPool]
 */
@JvmName("describeCoipPoolsResponseCoipPool")
fun Flow<DescribeCoipPoolsResponse>.coipPools(): Flow<CoipPool> =
    transform() { response ->
        response.coipPools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeDhcpOptionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeDhcpOptionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeDhcpOptionsResponse]
 */
fun Ec2Client.describeDhcpOptionsPaginated(initialRequest: DescribeDhcpOptionsRequest): Flow<DescribeDhcpOptionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeDhcpOptionsPaginated.describeDhcpOptions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeDhcpOptionsPaginated]
 * to access the nested member [DhcpOptions]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DhcpOptions]
 */
@JvmName("describeDhcpOptionsResponseDhcpOptions")
fun Flow<DescribeDhcpOptionsResponse>.dhcpOptions(): Flow<DhcpOptions> =
    transform() { response ->
        response.dhcpOptions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeEgressOnlyInternetGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeEgressOnlyInternetGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeEgressOnlyInternetGatewaysResponse]
 */
fun Ec2Client.describeEgressOnlyInternetGatewaysPaginated(initialRequest: DescribeEgressOnlyInternetGatewaysRequest): Flow<DescribeEgressOnlyInternetGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeEgressOnlyInternetGatewaysPaginated.describeEgressOnlyInternetGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeEgressOnlyInternetGatewaysPaginated]
 * to access the nested member [EgressOnlyInternetGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [EgressOnlyInternetGateway]
 */
@JvmName("describeEgressOnlyInternetGatewaysResponseEgressOnlyInternetGateway")
fun Flow<DescribeEgressOnlyInternetGatewaysResponse>.egressOnlyInternetGateways(): Flow<EgressOnlyInternetGateway> =
    transform() { response ->
        response.egressOnlyInternetGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeExportImageTasksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeExportImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeExportImageTasksResponse]
 */
fun Ec2Client.describeExportImageTasksPaginated(initialRequest: DescribeExportImageTasksRequest): Flow<DescribeExportImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeExportImageTasksPaginated.describeExportImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeExportImageTasksPaginated]
 * to access the nested member [ExportImageTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ExportImageTask]
 */
@JvmName("describeExportImageTasksResponseExportImageTask")
fun Flow<DescribeExportImageTasksResponse>.exportImageTasks(): Flow<ExportImageTask> =
    transform() { response ->
        response.exportImageTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFastLaunchImagesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeFastLaunchImagesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastLaunchImagesResponse]
 */
fun Ec2Client.describeFastLaunchImagesPaginated(initialRequest: DescribeFastLaunchImagesRequest): Flow<DescribeFastLaunchImagesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFastLaunchImagesPaginated.describeFastLaunchImages(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeFastLaunchImagesPaginated]
 * to access the nested member [DescribeFastLaunchImagesSuccessItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastLaunchImagesSuccessItem]
 */
@JvmName("describeFastLaunchImagesResponseDescribeFastLaunchImagesSuccessItem")
fun Flow<DescribeFastLaunchImagesResponse>.fastLaunchImages(): Flow<DescribeFastLaunchImagesSuccessItem> =
    transform() { response ->
        response.fastLaunchImages?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFastSnapshotRestoresResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeFastSnapshotRestoresRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastSnapshotRestoresResponse]
 */
fun Ec2Client.describeFastSnapshotRestoresPaginated(initialRequest: DescribeFastSnapshotRestoresRequest): Flow<DescribeFastSnapshotRestoresResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFastSnapshotRestoresPaginated.describeFastSnapshotRestores(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeFastSnapshotRestoresPaginated]
 * to access the nested member [DescribeFastSnapshotRestoreSuccessItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastSnapshotRestoreSuccessItem]
 */
@JvmName("describeFastSnapshotRestoresResponseDescribeFastSnapshotRestoreSuccessItem")
fun Flow<DescribeFastSnapshotRestoresResponse>.fastSnapshotRestores(): Flow<DescribeFastSnapshotRestoreSuccessItem> =
    transform() { response ->
        response.fastSnapshotRestores?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFleetsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeFleetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFleetsResponse]
 */
fun Ec2Client.describeFleetsPaginated(initialRequest: DescribeFleetsRequest): Flow<DescribeFleetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFleetsPaginated.describeFleets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeFleetsPaginated]
 * to access the nested member [FleetData]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FleetData]
 */
@JvmName("describeFleetsResponseFleetData")
fun Flow<DescribeFleetsResponse>.fleets(): Flow<FleetData> =
    transform() { response ->
        response.fleets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFlowLogsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeFlowLogsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFlowLogsResponse]
 */
fun Ec2Client.describeFlowLogsPaginated(initialRequest: DescribeFlowLogsRequest): Flow<DescribeFlowLogsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFlowLogsPaginated.describeFlowLogs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeFlowLogsPaginated]
 * to access the nested member [FlowLog]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FlowLog]
 */
@JvmName("describeFlowLogsResponseFlowLog")
fun Flow<DescribeFlowLogsResponse>.flowLogs(): Flow<FlowLog> =
    transform() { response ->
        response.flowLogs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFpgaImagesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeFpgaImagesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFpgaImagesResponse]
 */
fun Ec2Client.describeFpgaImagesPaginated(initialRequest: DescribeFpgaImagesRequest): Flow<DescribeFpgaImagesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFpgaImagesPaginated.describeFpgaImages(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeFpgaImagesPaginated]
 * to access the nested member [FpgaImage]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FpgaImage]
 */
@JvmName("describeFpgaImagesResponseFpgaImage")
fun Flow<DescribeFpgaImagesResponse>.fpgaImages(): Flow<FpgaImage> =
    transform() { response ->
        response.fpgaImages?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostReservationOfferingsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeHostReservationOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationOfferingsResponse]
 */
fun Ec2Client.describeHostReservationOfferingsPaginated(initialRequest: DescribeHostReservationOfferingsRequest): Flow<DescribeHostReservationOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostReservationOfferingsPaginated.describeHostReservationOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeHostReservationOfferingsPaginated]
 * to access the nested member [HostOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [HostOffering]
 */
@JvmName("describeHostReservationOfferingsResponseHostOffering")
fun Flow<DescribeHostReservationOfferingsResponse>.offeringSet(): Flow<HostOffering> =
    transform() { response ->
        response.offeringSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostReservationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeHostReservationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationsResponse]
 */
fun Ec2Client.describeHostReservationsPaginated(initialRequest: DescribeHostReservationsRequest): Flow<DescribeHostReservationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostReservationsPaginated.describeHostReservations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeHostReservationsPaginated]
 * to access the nested member [HostReservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [HostReservation]
 */
@JvmName("describeHostReservationsResponseHostReservation")
fun Flow<DescribeHostReservationsResponse>.hostReservationSet(): Flow<HostReservation> =
    transform() { response ->
        response.hostReservationSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeHostsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostsResponse]
 */
fun Ec2Client.describeHostsPaginated(initialRequest: DescribeHostsRequest): Flow<DescribeHostsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostsPaginated.describeHosts(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeHostsPaginated]
 * to access the nested member [Host]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Host]
 */
@JvmName("describeHostsResponseHost")
fun Flow<DescribeHostsResponse>.hosts(): Flow<Host> =
    transform() { response ->
        response.hosts?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIamInstanceProfileAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeIamInstanceProfileAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIamInstanceProfileAssociationsResponse]
 */
fun Ec2Client.describeIamInstanceProfileAssociationsPaginated(initialRequest: DescribeIamInstanceProfileAssociationsRequest): Flow<DescribeIamInstanceProfileAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIamInstanceProfileAssociationsPaginated.describeIamInstanceProfileAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeIamInstanceProfileAssociationsPaginated]
 * to access the nested member [IamInstanceProfileAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IamInstanceProfileAssociation]
 */
@JvmName("describeIamInstanceProfileAssociationsResponseIamInstanceProfileAssociation")
fun Flow<DescribeIamInstanceProfileAssociationsResponse>.iamInstanceProfileAssociations(): Flow<IamInstanceProfileAssociation> =
    transform() { response ->
        response.iamInstanceProfileAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeImportImageTasksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeImportImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportImageTasksResponse]
 */
fun Ec2Client.describeImportImageTasksPaginated(initialRequest: DescribeImportImageTasksRequest): Flow<DescribeImportImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeImportImageTasksPaginated.describeImportImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeImportImageTasksPaginated]
 * to access the nested member [ImportImageTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ImportImageTask]
 */
@JvmName("describeImportImageTasksResponseImportImageTask")
fun Flow<DescribeImportImageTasksResponse>.importImageTasks(): Flow<ImportImageTask> =
    transform() { response ->
        response.importImageTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeImportSnapshotTasksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeImportSnapshotTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportSnapshotTasksResponse]
 */
fun Ec2Client.describeImportSnapshotTasksPaginated(initialRequest: DescribeImportSnapshotTasksRequest): Flow<DescribeImportSnapshotTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeImportSnapshotTasksPaginated.describeImportSnapshotTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeImportSnapshotTasksPaginated]
 * to access the nested member [ImportSnapshotTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ImportSnapshotTask]
 */
@JvmName("describeImportSnapshotTasksResponseImportSnapshotTask")
fun Flow<DescribeImportSnapshotTasksResponse>.importSnapshotTasks(): Flow<ImportSnapshotTask> =
    transform() { response ->
        response.importSnapshotTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceCreditSpecificationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstanceCreditSpecificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceCreditSpecificationsResponse]
 */
fun Ec2Client.describeInstanceCreditSpecificationsPaginated(initialRequest: DescribeInstanceCreditSpecificationsRequest): Flow<DescribeInstanceCreditSpecificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceCreditSpecificationsPaginated.describeInstanceCreditSpecifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstanceCreditSpecificationsPaginated]
 * to access the nested member [InstanceCreditSpecification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceCreditSpecification]
 */
@JvmName("describeInstanceCreditSpecificationsResponseInstanceCreditSpecification")
fun Flow<DescribeInstanceCreditSpecificationsResponse>.instanceCreditSpecifications(): Flow<InstanceCreditSpecification> =
    transform() { response ->
        response.instanceCreditSpecifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceEventWindowsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstanceEventWindowsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceEventWindowsResponse]
 */
fun Ec2Client.describeInstanceEventWindowsPaginated(initialRequest: DescribeInstanceEventWindowsRequest): Flow<DescribeInstanceEventWindowsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceEventWindowsPaginated.describeInstanceEventWindows(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstanceEventWindowsPaginated]
 * to access the nested member [InstanceEventWindow]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceEventWindow]
 */
@JvmName("describeInstanceEventWindowsResponseInstanceEventWindow")
fun Flow<DescribeInstanceEventWindowsResponse>.instanceEventWindows(): Flow<InstanceEventWindow> =
    transform() { response ->
        response.instanceEventWindows?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstancesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstancesResponse]
 */
fun Ec2Client.describeInstancesPaginated(initialRequest: DescribeInstancesRequest): Flow<DescribeInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstancesPaginated.describeInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstancesPaginated]
 * to access the nested member [Reservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Reservation]
 */
@JvmName("describeInstancesResponseReservation")
fun Flow<DescribeInstancesResponse>.reservations(): Flow<Reservation> =
    transform() { response ->
        response.reservations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceStatusResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstanceStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceStatusResponse]
 */
fun Ec2Client.describeInstanceStatusPaginated(initialRequest: DescribeInstanceStatusRequest): Flow<DescribeInstanceStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceStatusPaginated.describeInstanceStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstanceStatusPaginated]
 * to access the nested member [InstanceStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceStatus]
 */
@JvmName("describeInstanceStatusResponseInstanceStatus")
fun Flow<DescribeInstanceStatusResponse>.instanceStatuses(): Flow<InstanceStatus> =
    transform() { response ->
        response.instanceStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceTypeOfferingsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstanceTypeOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypeOfferingsResponse]
 */
fun Ec2Client.describeInstanceTypeOfferingsPaginated(initialRequest: DescribeInstanceTypeOfferingsRequest): Flow<DescribeInstanceTypeOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceTypeOfferingsPaginated.describeInstanceTypeOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstanceTypeOfferingsPaginated]
 * to access the nested member [InstanceTypeOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeOffering]
 */
@JvmName("describeInstanceTypeOfferingsResponseInstanceTypeOffering")
fun Flow<DescribeInstanceTypeOfferingsResponse>.instanceTypeOfferings(): Flow<InstanceTypeOffering> =
    transform() { response ->
        response.instanceTypeOfferings?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceTypesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInstanceTypesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypesResponse]
 */
fun Ec2Client.describeInstanceTypesPaginated(initialRequest: DescribeInstanceTypesRequest): Flow<DescribeInstanceTypesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceTypesPaginated.describeInstanceTypes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInstanceTypesPaginated]
 * to access the nested member [InstanceTypeInfo]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeInfo]
 */
@JvmName("describeInstanceTypesResponseInstanceTypeInfo")
fun Flow<DescribeInstanceTypesResponse>.instanceTypes(): Flow<InstanceTypeInfo> =
    transform() { response ->
        response.instanceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInternetGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeInternetGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInternetGatewaysResponse]
 */
fun Ec2Client.describeInternetGatewaysPaginated(initialRequest: DescribeInternetGatewaysRequest): Flow<DescribeInternetGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInternetGatewaysPaginated.describeInternetGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeInternetGatewaysPaginated]
 * to access the nested member [InternetGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InternetGateway]
 */
@JvmName("describeInternetGatewaysResponseInternetGateway")
fun Flow<DescribeInternetGatewaysResponse>.internetGateways(): Flow<InternetGateway> =
    transform() { response ->
        response.internetGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamPoolsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeIpamPoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamPoolsResponse]
 */
fun Ec2Client.describeIpamPoolsPaginated(initialRequest: DescribeIpamPoolsRequest): Flow<DescribeIpamPoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamPoolsPaginated.describeIpamPools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeIpamPoolsPaginated]
 * to access the nested member [IpamPool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPool]
 */
@JvmName("describeIpamPoolsResponseIpamPool")
fun Flow<DescribeIpamPoolsResponse>.ipamPools(): Flow<IpamPool> =
    transform() { response ->
        response.ipamPools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeIpamsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamsResponse]
 */
fun Ec2Client.describeIpamsPaginated(initialRequest: DescribeIpamsRequest): Flow<DescribeIpamsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamsPaginated.describeIpams(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeIpamsPaginated]
 * to access the nested member [Ipam]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipam]
 */
@JvmName("describeIpamsResponseIpam")
fun Flow<DescribeIpamsResponse>.ipams(): Flow<Ipam> =
    transform() { response ->
        response.ipams?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamScopesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeIpamScopesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamScopesResponse]
 */
fun Ec2Client.describeIpamScopesPaginated(initialRequest: DescribeIpamScopesRequest): Flow<DescribeIpamScopesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamScopesPaginated.describeIpamScopes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeIpamScopesPaginated]
 * to access the nested member [IpamScope]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamScope]
 */
@JvmName("describeIpamScopesResponseIpamScope")
fun Flow<DescribeIpamScopesResponse>.ipamScopes(): Flow<IpamScope> =
    transform() { response ->
        response.ipamScopes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpv6PoolsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeIpv6PoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpv6PoolsResponse]
 */
fun Ec2Client.describeIpv6PoolsPaginated(initialRequest: DescribeIpv6PoolsRequest): Flow<DescribeIpv6PoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpv6PoolsPaginated.describeIpv6Pools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeIpv6PoolsPaginated]
 * to access the nested member [Ipv6Pool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipv6Pool]
 */
@JvmName("describeIpv6PoolsResponseIpv6Pool")
fun Flow<DescribeIpv6PoolsResponse>.ipv6Pools(): Flow<Ipv6Pool> =
    transform() { response ->
        response.ipv6Pools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplatesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLaunchTemplatesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplatesResponse]
 */
fun Ec2Client.describeLaunchTemplatesPaginated(initialRequest: DescribeLaunchTemplatesRequest): Flow<DescribeLaunchTemplatesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLaunchTemplatesPaginated.describeLaunchTemplates(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLaunchTemplatesPaginated]
 * to access the nested member [LaunchTemplate]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LaunchTemplate]
 */
@JvmName("describeLaunchTemplatesResponseLaunchTemplate")
fun Flow<DescribeLaunchTemplatesResponse>.launchTemplates(): Flow<LaunchTemplate> =
    transform() { response ->
        response.launchTemplates?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplateVersionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLaunchTemplateVersionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplateVersionsResponse]
 */
fun Ec2Client.describeLaunchTemplateVersionsPaginated(initialRequest: DescribeLaunchTemplateVersionsRequest): Flow<DescribeLaunchTemplateVersionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLaunchTemplateVersionsPaginated.describeLaunchTemplateVersions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLaunchTemplateVersionsPaginated]
 * to access the nested member [LaunchTemplateVersion]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LaunchTemplateVersion]
 */
@JvmName("describeLaunchTemplateVersionsResponseLaunchTemplateVersion")
fun Flow<DescribeLaunchTemplateVersionsResponse>.launchTemplateVersions(): Flow<LaunchTemplateVersion> =
    transform() { response ->
        response.launchTemplateVersions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTablesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTablesResponse]
 */
fun Ec2Client.describeLocalGatewayRouteTablesPaginated(initialRequest: DescribeLocalGatewayRouteTablesRequest): Flow<DescribeLocalGatewayRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTablesPaginated.describeLocalGatewayRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTablesPaginated]
 * to access the nested member [LocalGatewayRouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTable]
 */
@JvmName("describeLocalGatewayRouteTablesResponseLocalGatewayRouteTable")
fun Flow<DescribeLocalGatewayRouteTablesResponse>.localGatewayRouteTables(): Flow<LocalGatewayRouteTable> =
    transform() { response ->
        response.localGatewayRouteTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse]
 */
fun Ec2Client.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated(initialRequest: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest): Flow<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated]
 * to access the nested member [LocalGatewayRouteTableVirtualInterfaceGroupAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTableVirtualInterfaceGroupAssociation]
 */
@JvmName("describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponseLocalGatewayRouteTableVirtualInterfaceGroupAssociation")
fun Flow<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse>.localGatewayRouteTableVirtualInterfaceGroupAssociations(): Flow<LocalGatewayRouteTableVirtualInterfaceGroupAssociation> =
    transform() { response ->
        response.localGatewayRouteTableVirtualInterfaceGroupAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVpcAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTableVpcAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVpcAssociationsResponse]
 */
fun Ec2Client.describeLocalGatewayRouteTableVpcAssociationsPaginated(initialRequest: DescribeLocalGatewayRouteTableVpcAssociationsRequest): Flow<DescribeLocalGatewayRouteTableVpcAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTableVpcAssociationsPaginated.describeLocalGatewayRouteTableVpcAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTableVpcAssociationsPaginated]
 * to access the nested member [LocalGatewayRouteTableVpcAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTableVpcAssociation]
 */
@JvmName("describeLocalGatewayRouteTableVpcAssociationsResponseLocalGatewayRouteTableVpcAssociation")
fun Flow<DescribeLocalGatewayRouteTableVpcAssociationsResponse>.localGatewayRouteTableVpcAssociations(): Flow<LocalGatewayRouteTableVpcAssociation> =
    transform() { response ->
        response.localGatewayRouteTableVpcAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewaysResponse]
 */
fun Ec2Client.describeLocalGatewaysPaginated(initialRequest: DescribeLocalGatewaysRequest): Flow<DescribeLocalGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewaysPaginated.describeLocalGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewaysPaginated]
 * to access the nested member [LocalGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGateway]
 */
@JvmName("describeLocalGatewaysResponseLocalGateway")
fun Flow<DescribeLocalGatewaysResponse>.localGateways(): Flow<LocalGateway> =
    transform() { response ->
        response.localGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfaceGroupsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewayVirtualInterfaceGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfaceGroupsResponse]
 */
fun Ec2Client.describeLocalGatewayVirtualInterfaceGroupsPaginated(initialRequest: DescribeLocalGatewayVirtualInterfaceGroupsRequest): Flow<DescribeLocalGatewayVirtualInterfaceGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayVirtualInterfaceGroupsPaginated.describeLocalGatewayVirtualInterfaceGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewayVirtualInterfaceGroupsPaginated]
 * to access the nested member [LocalGatewayVirtualInterfaceGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayVirtualInterfaceGroup]
 */
@JvmName("describeLocalGatewayVirtualInterfaceGroupsResponseLocalGatewayVirtualInterfaceGroup")
fun Flow<DescribeLocalGatewayVirtualInterfaceGroupsResponse>.localGatewayVirtualInterfaceGroups(): Flow<LocalGatewayVirtualInterfaceGroup> =
    transform() { response ->
        response.localGatewayVirtualInterfaceGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfacesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeLocalGatewayVirtualInterfacesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfacesResponse]
 */
fun Ec2Client.describeLocalGatewayVirtualInterfacesPaginated(initialRequest: DescribeLocalGatewayVirtualInterfacesRequest): Flow<DescribeLocalGatewayVirtualInterfacesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayVirtualInterfacesPaginated.describeLocalGatewayVirtualInterfaces(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeLocalGatewayVirtualInterfacesPaginated]
 * to access the nested member [LocalGatewayVirtualInterface]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayVirtualInterface]
 */
@JvmName("describeLocalGatewayVirtualInterfacesResponseLocalGatewayVirtualInterface")
fun Flow<DescribeLocalGatewayVirtualInterfacesResponse>.localGatewayVirtualInterfaces(): Flow<LocalGatewayVirtualInterface> =
    transform() { response ->
        response.localGatewayVirtualInterfaces?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeManagedPrefixListsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeManagedPrefixListsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeManagedPrefixListsResponse]
 */
fun Ec2Client.describeManagedPrefixListsPaginated(initialRequest: DescribeManagedPrefixListsRequest): Flow<DescribeManagedPrefixListsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeManagedPrefixListsPaginated.describeManagedPrefixLists(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeManagedPrefixListsPaginated]
 * to access the nested member [ManagedPrefixList]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ManagedPrefixList]
 */
@JvmName("describeManagedPrefixListsResponseManagedPrefixList")
fun Flow<DescribeManagedPrefixListsResponse>.prefixLists(): Flow<ManagedPrefixList> =
    transform() { response ->
        response.prefixLists?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeMovingAddressesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeMovingAddressesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeMovingAddressesResponse]
 */
fun Ec2Client.describeMovingAddressesPaginated(initialRequest: DescribeMovingAddressesRequest): Flow<DescribeMovingAddressesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeMovingAddressesPaginated.describeMovingAddresses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeMovingAddressesPaginated]
 * to access the nested member [MovingAddressStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [MovingAddressStatus]
 */
@JvmName("describeMovingAddressesResponseMovingAddressStatus")
fun Flow<DescribeMovingAddressesResponse>.movingAddressStatuses(): Flow<MovingAddressStatus> =
    transform() { response ->
        response.movingAddressStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNatGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNatGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNatGatewaysResponse]
 */
fun Ec2Client.describeNatGatewaysPaginated(initialRequest: DescribeNatGatewaysRequest): Flow<DescribeNatGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNatGatewaysPaginated.describeNatGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNatGatewaysPaginated]
 * to access the nested member [NatGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NatGateway]
 */
@JvmName("describeNatGatewaysResponseNatGateway")
fun Flow<DescribeNatGatewaysResponse>.natGateways(): Flow<NatGateway> =
    transform() { response ->
        response.natGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkAclsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkAclsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkAclsResponse]
 */
fun Ec2Client.describeNetworkAclsPaginated(initialRequest: DescribeNetworkAclsRequest): Flow<DescribeNetworkAclsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkAclsPaginated.describeNetworkAcls(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkAclsPaginated]
 * to access the nested member [NetworkAcl]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkAcl]
 */
@JvmName("describeNetworkAclsResponseNetworkAcl")
fun Flow<DescribeNetworkAclsResponse>.networkAcls(): Flow<NetworkAcl> =
    transform() { response ->
        response.networkAcls?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopeAnalysesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInsightsAccessScopeAnalysesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopeAnalysesResponse]
 */
fun Ec2Client.describeNetworkInsightsAccessScopeAnalysesPaginated(initialRequest: DescribeNetworkInsightsAccessScopeAnalysesRequest): Flow<DescribeNetworkInsightsAccessScopeAnalysesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAccessScopeAnalysesPaginated.describeNetworkInsightsAccessScopeAnalyses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAccessScopeAnalysesPaginated]
 * to access the nested member [NetworkInsightsAccessScopeAnalysis]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAccessScopeAnalysis]
 */
@JvmName("describeNetworkInsightsAccessScopeAnalysesResponseNetworkInsightsAccessScopeAnalysis")
fun Flow<DescribeNetworkInsightsAccessScopeAnalysesResponse>.networkInsightsAccessScopeAnalyses(): Flow<NetworkInsightsAccessScopeAnalysis> =
    transform() { response ->
        response.networkInsightsAccessScopeAnalyses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInsightsAccessScopesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopesResponse]
 */
fun Ec2Client.describeNetworkInsightsAccessScopesPaginated(initialRequest: DescribeNetworkInsightsAccessScopesRequest): Flow<DescribeNetworkInsightsAccessScopesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAccessScopesPaginated.describeNetworkInsightsAccessScopes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAccessScopesPaginated]
 * to access the nested member [NetworkInsightsAccessScope]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAccessScope]
 */
@JvmName("describeNetworkInsightsAccessScopesResponseNetworkInsightsAccessScope")
fun Flow<DescribeNetworkInsightsAccessScopesResponse>.networkInsightsAccessScopes(): Flow<NetworkInsightsAccessScope> =
    transform() { response ->
        response.networkInsightsAccessScopes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAnalysesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInsightsAnalysesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAnalysesResponse]
 */
fun Ec2Client.describeNetworkInsightsAnalysesPaginated(initialRequest: DescribeNetworkInsightsAnalysesRequest): Flow<DescribeNetworkInsightsAnalysesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAnalysesPaginated.describeNetworkInsightsAnalyses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAnalysesPaginated]
 * to access the nested member [NetworkInsightsAnalysis]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAnalysis]
 */
@JvmName("describeNetworkInsightsAnalysesResponseNetworkInsightsAnalysis")
fun Flow<DescribeNetworkInsightsAnalysesResponse>.networkInsightsAnalyses(): Flow<NetworkInsightsAnalysis> =
    transform() { response ->
        response.networkInsightsAnalyses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsPathsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInsightsPathsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsPathsResponse]
 */
fun Ec2Client.describeNetworkInsightsPathsPaginated(initialRequest: DescribeNetworkInsightsPathsRequest): Flow<DescribeNetworkInsightsPathsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsPathsPaginated.describeNetworkInsightsPaths(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsPathsPaginated]
 * to access the nested member [NetworkInsightsPath]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsPath]
 */
@JvmName("describeNetworkInsightsPathsResponseNetworkInsightsPath")
fun Flow<DescribeNetworkInsightsPathsResponse>.networkInsightsPaths(): Flow<NetworkInsightsPath> =
    transform() { response ->
        response.networkInsightsPaths?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacePermissionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInterfacePermissionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacePermissionsResponse]
 */
fun Ec2Client.describeNetworkInterfacePermissionsPaginated(initialRequest: DescribeNetworkInterfacePermissionsRequest): Flow<DescribeNetworkInterfacePermissionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInterfacePermissionsPaginated.describeNetworkInterfacePermissions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInterfacePermissionsPaginated]
 * to access the nested member [NetworkInterfacePermission]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInterfacePermission]
 */
@JvmName("describeNetworkInterfacePermissionsResponseNetworkInterfacePermission")
fun Flow<DescribeNetworkInterfacePermissionsResponse>.networkInterfacePermissions(): Flow<NetworkInterfacePermission> =
    transform() { response ->
        response.networkInterfacePermissions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeNetworkInterfacesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacesResponse]
 */
fun Ec2Client.describeNetworkInterfacesPaginated(initialRequest: DescribeNetworkInterfacesRequest): Flow<DescribeNetworkInterfacesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInterfacesPaginated.describeNetworkInterfaces(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeNetworkInterfacesPaginated]
 * to access the nested member [NetworkInterface]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInterface]
 */
@JvmName("describeNetworkInterfacesResponseNetworkInterface")
fun Flow<DescribeNetworkInterfacesResponse>.networkInterfaces(): Flow<NetworkInterface> =
    transform() { response ->
        response.networkInterfaces?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePrefixListsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribePrefixListsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrefixListsResponse]
 */
fun Ec2Client.describePrefixListsPaginated(initialRequest: DescribePrefixListsRequest): Flow<DescribePrefixListsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePrefixListsPaginated.describePrefixLists(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describePrefixListsPaginated]
 * to access the nested member [PrefixList]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixList]
 */
@JvmName("describePrefixListsResponsePrefixList")
fun Flow<DescribePrefixListsResponse>.prefixLists(): Flow<PrefixList> =
    transform() { response ->
        response.prefixLists?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePrincipalIdFormatResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribePrincipalIdFormatRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrincipalIdFormatResponse]
 */
fun Ec2Client.describePrincipalIdFormatPaginated(initialRequest: DescribePrincipalIdFormatRequest): Flow<DescribePrincipalIdFormatResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePrincipalIdFormatPaginated.describePrincipalIdFormat(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describePrincipalIdFormatPaginated]
 * to access the nested member [PrincipalIdFormat]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrincipalIdFormat]
 */
@JvmName("describePrincipalIdFormatResponsePrincipalIdFormat")
fun Flow<DescribePrincipalIdFormatResponse>.principals(): Flow<PrincipalIdFormat> =
    transform() { response ->
        response.principals?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePublicIpv4PoolsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribePublicIpv4PoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePublicIpv4PoolsResponse]
 */
fun Ec2Client.describePublicIpv4PoolsPaginated(initialRequest: DescribePublicIpv4PoolsRequest): Flow<DescribePublicIpv4PoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePublicIpv4PoolsPaginated.describePublicIpv4Pools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describePublicIpv4PoolsPaginated]
 * to access the nested member [PublicIpv4Pool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PublicIpv4Pool]
 */
@JvmName("describePublicIpv4PoolsResponsePublicIpv4Pool")
fun Flow<DescribePublicIpv4PoolsResponse>.publicIpv4Pools(): Flow<PublicIpv4Pool> =
    transform() { response ->
        response.publicIpv4Pools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReplaceRootVolumeTasksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeReplaceRootVolumeTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReplaceRootVolumeTasksResponse]
 */
fun Ec2Client.describeReplaceRootVolumeTasksPaginated(initialRequest: DescribeReplaceRootVolumeTasksRequest): Flow<DescribeReplaceRootVolumeTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReplaceRootVolumeTasksPaginated.describeReplaceRootVolumeTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeReplaceRootVolumeTasksPaginated]
 * to access the nested member [ReplaceRootVolumeTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReplaceRootVolumeTask]
 */
@JvmName("describeReplaceRootVolumeTasksResponseReplaceRootVolumeTask")
fun Flow<DescribeReplaceRootVolumeTasksResponse>.replaceRootVolumeTasks(): Flow<ReplaceRootVolumeTask> =
    transform() { response ->
        response.replaceRootVolumeTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesModificationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeReservedInstancesModificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesModificationsResponse]
 */
fun Ec2Client.describeReservedInstancesModificationsPaginated(initialRequest: DescribeReservedInstancesModificationsRequest): Flow<DescribeReservedInstancesModificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReservedInstancesModificationsPaginated.describeReservedInstancesModifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeReservedInstancesModificationsPaginated]
 * to access the nested member [ReservedInstancesModification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReservedInstancesModification]
 */
@JvmName("describeReservedInstancesModificationsResponseReservedInstancesModification")
fun Flow<DescribeReservedInstancesModificationsResponse>.reservedInstancesModifications(): Flow<ReservedInstancesModification> =
    transform() { response ->
        response.reservedInstancesModifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesOfferingsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeReservedInstancesOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesOfferingsResponse]
 */
fun Ec2Client.describeReservedInstancesOfferingsPaginated(initialRequest: DescribeReservedInstancesOfferingsRequest): Flow<DescribeReservedInstancesOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReservedInstancesOfferingsPaginated.describeReservedInstancesOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeReservedInstancesOfferingsPaginated]
 * to access the nested member [ReservedInstancesOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReservedInstancesOffering]
 */
@JvmName("describeReservedInstancesOfferingsResponseReservedInstancesOffering")
fun Flow<DescribeReservedInstancesOfferingsResponse>.reservedInstancesOfferings(): Flow<ReservedInstancesOffering> =
    transform() { response ->
        response.reservedInstancesOfferings?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeRouteTablesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeRouteTablesResponse]
 */
fun Ec2Client.describeRouteTablesPaginated(initialRequest: DescribeRouteTablesRequest): Flow<DescribeRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeRouteTablesPaginated.describeRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeRouteTablesPaginated]
 * to access the nested member [RouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [RouteTable]
 */
@JvmName("describeRouteTablesResponseRouteTable")
fun Flow<DescribeRouteTablesResponse>.routeTables(): Flow<RouteTable> =
    transform() { response ->
        response.routeTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeScheduledInstanceAvailabilityResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeScheduledInstanceAvailabilityRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstanceAvailabilityResponse]
 */
fun Ec2Client.describeScheduledInstanceAvailabilityPaginated(initialRequest: DescribeScheduledInstanceAvailabilityRequest): Flow<DescribeScheduledInstanceAvailabilityResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeScheduledInstanceAvailabilityPaginated.describeScheduledInstanceAvailability(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeScheduledInstanceAvailabilityPaginated]
 * to access the nested member [ScheduledInstanceAvailability]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ScheduledInstanceAvailability]
 */
@JvmName("describeScheduledInstanceAvailabilityResponseScheduledInstanceAvailability")
fun Flow<DescribeScheduledInstanceAvailabilityResponse>.scheduledInstanceAvailabilitySet(): Flow<ScheduledInstanceAvailability> =
    transform() { response ->
        response.scheduledInstanceAvailabilitySet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeScheduledInstancesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeScheduledInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstancesResponse]
 */
fun Ec2Client.describeScheduledInstancesPaginated(initialRequest: DescribeScheduledInstancesRequest): Flow<DescribeScheduledInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeScheduledInstancesPaginated.describeScheduledInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeScheduledInstancesPaginated]
 * to access the nested member [ScheduledInstance]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ScheduledInstance]
 */
@JvmName("describeScheduledInstancesResponseScheduledInstance")
fun Flow<DescribeScheduledInstancesResponse>.scheduledInstanceSet(): Flow<ScheduledInstance> =
    transform() { response ->
        response.scheduledInstanceSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupRulesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSecurityGroupRulesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupRulesResponse]
 */
fun Ec2Client.describeSecurityGroupRulesPaginated(initialRequest: DescribeSecurityGroupRulesRequest): Flow<DescribeSecurityGroupRulesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSecurityGroupRulesPaginated.describeSecurityGroupRules(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSecurityGroupRulesPaginated]
 * to access the nested member [SecurityGroupRule]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SecurityGroupRule]
 */
@JvmName("describeSecurityGroupRulesResponseSecurityGroupRule")
fun Flow<DescribeSecurityGroupRulesResponse>.securityGroupRules(): Flow<SecurityGroupRule> =
    transform() { response ->
        response.securityGroupRules?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSecurityGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupsResponse]
 */
fun Ec2Client.describeSecurityGroupsPaginated(initialRequest: DescribeSecurityGroupsRequest): Flow<DescribeSecurityGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSecurityGroupsPaginated.describeSecurityGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSecurityGroupsPaginated]
 * to access the nested member [SecurityGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SecurityGroup]
 */
@JvmName("describeSecurityGroupsResponseSecurityGroup")
fun Flow<DescribeSecurityGroupsResponse>.securityGroups(): Flow<SecurityGroup> =
    transform() { response ->
        response.securityGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSnapshotsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSnapshotsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotsResponse]
 */
fun Ec2Client.describeSnapshotsPaginated(initialRequest: DescribeSnapshotsRequest): Flow<DescribeSnapshotsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSnapshotsPaginated.describeSnapshots(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSnapshotsPaginated]
 * to access the nested member [Snapshot]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Snapshot]
 */
@JvmName("describeSnapshotsResponseSnapshot")
fun Flow<DescribeSnapshotsResponse>.snapshots(): Flow<Snapshot> =
    transform() { response ->
        response.snapshots?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSnapshotTierStatusResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSnapshotTierStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotTierStatusResponse]
 */
fun Ec2Client.describeSnapshotTierStatusPaginated(initialRequest: DescribeSnapshotTierStatusRequest): Flow<DescribeSnapshotTierStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSnapshotTierStatusPaginated.describeSnapshotTierStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSnapshotTierStatusPaginated]
 * to access the nested member [SnapshotTierStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SnapshotTierStatus]
 */
@JvmName("describeSnapshotTierStatusResponseSnapshotTierStatus")
fun Flow<DescribeSnapshotTierStatusResponse>.snapshotTierStatuses(): Flow<SnapshotTierStatus> =
    transform() { response ->
        response.snapshotTierStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotFleetRequestsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSpotFleetRequestsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotFleetRequestsResponse]
 */
fun Ec2Client.describeSpotFleetRequestsPaginated(initialRequest: DescribeSpotFleetRequestsRequest): Flow<DescribeSpotFleetRequestsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotFleetRequestsPaginated.describeSpotFleetRequests(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSpotFleetRequestsPaginated]
 * to access the nested member [SpotFleetRequestConfig]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotFleetRequestConfig]
 */
@JvmName("describeSpotFleetRequestsResponseSpotFleetRequestConfig")
fun Flow<DescribeSpotFleetRequestsResponse>.spotFleetRequestConfigs(): Flow<SpotFleetRequestConfig> =
    transform() { response ->
        response.spotFleetRequestConfigs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotInstanceRequestsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSpotInstanceRequestsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotInstanceRequestsResponse]
 */
fun Ec2Client.describeSpotInstanceRequestsPaginated(initialRequest: DescribeSpotInstanceRequestsRequest): Flow<DescribeSpotInstanceRequestsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotInstanceRequestsPaginated.describeSpotInstanceRequests(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSpotInstanceRequestsPaginated]
 * to access the nested member [SpotInstanceRequest]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotInstanceRequest]
 */
@JvmName("describeSpotInstanceRequestsResponseSpotInstanceRequest")
fun Flow<DescribeSpotInstanceRequestsResponse>.spotInstanceRequests(): Flow<SpotInstanceRequest> =
    transform() { response ->
        response.spotInstanceRequests?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotPriceHistoryResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSpotPriceHistoryRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotPriceHistoryResponse]
 */
fun Ec2Client.describeSpotPriceHistoryPaginated(initialRequest: DescribeSpotPriceHistoryRequest): Flow<DescribeSpotPriceHistoryResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotPriceHistoryPaginated.describeSpotPriceHistory(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSpotPriceHistoryPaginated]
 * to access the nested member [SpotPrice]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotPrice]
 */
@JvmName("describeSpotPriceHistoryResponseSpotPrice")
fun Flow<DescribeSpotPriceHistoryResponse>.spotPriceHistory(): Flow<SpotPrice> =
    transform() { response ->
        response.spotPriceHistory?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeStaleSecurityGroupsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeStaleSecurityGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStaleSecurityGroupsResponse]
 */
fun Ec2Client.describeStaleSecurityGroupsPaginated(initialRequest: DescribeStaleSecurityGroupsRequest): Flow<DescribeStaleSecurityGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeStaleSecurityGroupsPaginated.describeStaleSecurityGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeStaleSecurityGroupsPaginated]
 * to access the nested member [StaleSecurityGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [StaleSecurityGroup]
 */
@JvmName("describeStaleSecurityGroupsResponseStaleSecurityGroup")
fun Flow<DescribeStaleSecurityGroupsResponse>.staleSecurityGroupSet(): Flow<StaleSecurityGroup> =
    transform() { response ->
        response.staleSecurityGroupSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeStoreImageTasksResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeStoreImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStoreImageTasksResponse]
 */
fun Ec2Client.describeStoreImageTasksPaginated(initialRequest: DescribeStoreImageTasksRequest): Flow<DescribeStoreImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeStoreImageTasksPaginated.describeStoreImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeStoreImageTasksPaginated]
 * to access the nested member [StoreImageTaskResult]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [StoreImageTaskResult]
 */
@JvmName("describeStoreImageTasksResponseStoreImageTaskResult")
fun Flow<DescribeStoreImageTasksResponse>.storeImageTaskResults(): Flow<StoreImageTaskResult> =
    transform() { response ->
        response.storeImageTaskResults?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSubnetsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeSubnetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSubnetsResponse]
 */
fun Ec2Client.describeSubnetsPaginated(initialRequest: DescribeSubnetsRequest): Flow<DescribeSubnetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSubnetsPaginated.describeSubnets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeSubnetsPaginated]
 * to access the nested member [Subnet]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Subnet]
 */
@JvmName("describeSubnetsResponseSubnet")
fun Flow<DescribeSubnetsResponse>.subnets(): Flow<Subnet> =
    transform() { response ->
        response.subnets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTagsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTagsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTagsResponse]
 */
fun Ec2Client.describeTagsPaginated(initialRequest: DescribeTagsRequest): Flow<DescribeTagsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTagsPaginated.describeTags(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTagsPaginated]
 * to access the nested member [TagDescription]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TagDescription]
 */
@JvmName("describeTagsResponseTagDescription")
fun Flow<DescribeTagsResponse>.tags(): Flow<TagDescription> =
    transform() { response ->
        response.tags?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorFiltersResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTrafficMirrorFiltersRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorFiltersResponse]
 */
fun Ec2Client.describeTrafficMirrorFiltersPaginated(initialRequest: DescribeTrafficMirrorFiltersRequest): Flow<DescribeTrafficMirrorFiltersResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorFiltersPaginated.describeTrafficMirrorFilters(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorFiltersPaginated]
 * to access the nested member [TrafficMirrorFilter]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorFilter]
 */
@JvmName("describeTrafficMirrorFiltersResponseTrafficMirrorFilter")
fun Flow<DescribeTrafficMirrorFiltersResponse>.trafficMirrorFilters(): Flow<TrafficMirrorFilter> =
    transform() { response ->
        response.trafficMirrorFilters?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorSessionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTrafficMirrorSessionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorSessionsResponse]
 */
fun Ec2Client.describeTrafficMirrorSessionsPaginated(initialRequest: DescribeTrafficMirrorSessionsRequest): Flow<DescribeTrafficMirrorSessionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorSessionsPaginated.describeTrafficMirrorSessions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorSessionsPaginated]
 * to access the nested member [TrafficMirrorSession]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorSession]
 */
@JvmName("describeTrafficMirrorSessionsResponseTrafficMirrorSession")
fun Flow<DescribeTrafficMirrorSessionsResponse>.trafficMirrorSessions(): Flow<TrafficMirrorSession> =
    transform() { response ->
        response.trafficMirrorSessions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorTargetsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTrafficMirrorTargetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorTargetsResponse]
 */
fun Ec2Client.describeTrafficMirrorTargetsPaginated(initialRequest: DescribeTrafficMirrorTargetsRequest): Flow<DescribeTrafficMirrorTargetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorTargetsPaginated.describeTrafficMirrorTargets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorTargetsPaginated]
 * to access the nested member [TrafficMirrorTarget]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorTarget]
 */
@JvmName("describeTrafficMirrorTargetsResponseTrafficMirrorTarget")
fun Flow<DescribeTrafficMirrorTargetsResponse>.trafficMirrorTargets(): Flow<TrafficMirrorTarget> =
    transform() { response ->
        response.trafficMirrorTargets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayAttachmentsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayAttachmentsResponse]
 */
fun Ec2Client.describeTransitGatewayAttachmentsPaginated(initialRequest: DescribeTransitGatewayAttachmentsRequest): Flow<DescribeTransitGatewayAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayAttachmentsPaginated.describeTransitGatewayAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayAttachmentsPaginated]
 * to access the nested member [TransitGatewayAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayAttachment]
 */
@JvmName("describeTransitGatewayAttachmentsResponseTransitGatewayAttachment")
fun Flow<DescribeTransitGatewayAttachmentsResponse>.transitGatewayAttachments(): Flow<TransitGatewayAttachment> =
    transform() { response ->
        response.transitGatewayAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectPeersResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayConnectPeersRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectPeersResponse]
 */
fun Ec2Client.describeTransitGatewayConnectPeersPaginated(initialRequest: DescribeTransitGatewayConnectPeersRequest): Flow<DescribeTransitGatewayConnectPeersResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayConnectPeersPaginated.describeTransitGatewayConnectPeers(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayConnectPeersPaginated]
 * to access the nested member [TransitGatewayConnectPeer]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayConnectPeer]
 */
@JvmName("describeTransitGatewayConnectPeersResponseTransitGatewayConnectPeer")
fun Flow<DescribeTransitGatewayConnectPeersResponse>.transitGatewayConnectPeers(): Flow<TransitGatewayConnectPeer> =
    transform() { response ->
        response.transitGatewayConnectPeers?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayConnectsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectsResponse]
 */
fun Ec2Client.describeTransitGatewayConnectsPaginated(initialRequest: DescribeTransitGatewayConnectsRequest): Flow<DescribeTransitGatewayConnectsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayConnectsPaginated.describeTransitGatewayConnects(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayConnectsPaginated]
 * to access the nested member [TransitGatewayConnect]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayConnect]
 */
@JvmName("describeTransitGatewayConnectsResponseTransitGatewayConnect")
fun Flow<DescribeTransitGatewayConnectsResponse>.transitGatewayConnects(): Flow<TransitGatewayConnect> =
    transform() { response ->
        response.transitGatewayConnects?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayMulticastDomainsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayMulticastDomainsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayMulticastDomainsResponse]
 */
fun Ec2Client.describeTransitGatewayMulticastDomainsPaginated(initialRequest: DescribeTransitGatewayMulticastDomainsRequest): Flow<DescribeTransitGatewayMulticastDomainsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayMulticastDomainsPaginated.describeTransitGatewayMulticastDomains(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayMulticastDomainsPaginated]
 * to access the nested member [TransitGatewayMulticastDomain]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastDomain]
 */
@JvmName("describeTransitGatewayMulticastDomainsResponseTransitGatewayMulticastDomain")
fun Flow<DescribeTransitGatewayMulticastDomainsResponse>.transitGatewayMulticastDomains(): Flow<TransitGatewayMulticastDomain> =
    transform() { response ->
        response.transitGatewayMulticastDomains?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayPeeringAttachmentsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayPeeringAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayPeeringAttachmentsResponse]
 */
fun Ec2Client.describeTransitGatewayPeeringAttachmentsPaginated(initialRequest: DescribeTransitGatewayPeeringAttachmentsRequest): Flow<DescribeTransitGatewayPeeringAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayPeeringAttachmentsPaginated.describeTransitGatewayPeeringAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayPeeringAttachmentsPaginated]
 * to access the nested member [TransitGatewayPeeringAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPeeringAttachment]
 */
@JvmName("describeTransitGatewayPeeringAttachmentsResponseTransitGatewayPeeringAttachment")
fun Flow<DescribeTransitGatewayPeeringAttachmentsResponse>.transitGatewayPeeringAttachments(): Flow<TransitGatewayPeeringAttachment> =
    transform() { response ->
        response.transitGatewayPeeringAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayRouteTablesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayRouteTablesResponse]
 */
fun Ec2Client.describeTransitGatewayRouteTablesPaginated(initialRequest: DescribeTransitGatewayRouteTablesRequest): Flow<DescribeTransitGatewayRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayRouteTablesPaginated.describeTransitGatewayRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayRouteTablesPaginated]
 * to access the nested member [TransitGatewayRouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTable]
 */
@JvmName("describeTransitGatewayRouteTablesResponseTransitGatewayRouteTable")
fun Flow<DescribeTransitGatewayRouteTablesResponse>.transitGatewayRouteTables(): Flow<TransitGatewayRouteTable> =
    transform() { response ->
        response.transitGatewayRouteTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewaysResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewaysResponse]
 */
fun Ec2Client.describeTransitGatewaysPaginated(initialRequest: DescribeTransitGatewaysRequest): Flow<DescribeTransitGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewaysPaginated.describeTransitGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewaysPaginated]
 * to access the nested member [TransitGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGateway]
 */
@JvmName("describeTransitGatewaysResponseTransitGateway")
fun Flow<DescribeTransitGatewaysResponse>.transitGateways(): Flow<TransitGateway> =
    transform() { response ->
        response.transitGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayVpcAttachmentsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTransitGatewayVpcAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayVpcAttachmentsResponse]
 */
fun Ec2Client.describeTransitGatewayVpcAttachmentsPaginated(initialRequest: DescribeTransitGatewayVpcAttachmentsRequest): Flow<DescribeTransitGatewayVpcAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayVpcAttachmentsPaginated.describeTransitGatewayVpcAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTransitGatewayVpcAttachmentsPaginated]
 * to access the nested member [TransitGatewayVpcAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayVpcAttachment]
 */
@JvmName("describeTransitGatewayVpcAttachmentsResponseTransitGatewayVpcAttachment")
fun Flow<DescribeTransitGatewayVpcAttachmentsResponse>.transitGatewayVpcAttachments(): Flow<TransitGatewayVpcAttachment> =
    transform() { response ->
        response.transitGatewayVpcAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrunkInterfaceAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeTrunkInterfaceAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrunkInterfaceAssociationsResponse]
 */
fun Ec2Client.describeTrunkInterfaceAssociationsPaginated(initialRequest: DescribeTrunkInterfaceAssociationsRequest): Flow<DescribeTrunkInterfaceAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrunkInterfaceAssociationsPaginated.describeTrunkInterfaceAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeTrunkInterfaceAssociationsPaginated]
 * to access the nested member [TrunkInterfaceAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrunkInterfaceAssociation]
 */
@JvmName("describeTrunkInterfaceAssociationsResponseTrunkInterfaceAssociation")
fun Flow<DescribeTrunkInterfaceAssociationsResponse>.interfaceAssociations(): Flow<TrunkInterfaceAssociation> =
    transform() { response ->
        response.interfaceAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVolumesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesResponse]
 */
fun Ec2Client.describeVolumesPaginated(initialRequest: DescribeVolumesRequest): Flow<DescribeVolumesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumesPaginated.describeVolumes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVolumesPaginated]
 * to access the nested member [Volume]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Volume]
 */
@JvmName("describeVolumesResponseVolume")
fun Flow<DescribeVolumesResponse>.volumes(): Flow<Volume> =
    transform() { response ->
        response.volumes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumesModificationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVolumesModificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesModificationsResponse]
 */
fun Ec2Client.describeVolumesModificationsPaginated(initialRequest: DescribeVolumesModificationsRequest): Flow<DescribeVolumesModificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumesModificationsPaginated.describeVolumesModifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVolumesModificationsPaginated]
 * to access the nested member [VolumeModification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VolumeModification]
 */
@JvmName("describeVolumesModificationsResponseVolumeModification")
fun Flow<DescribeVolumesModificationsResponse>.volumesModifications(): Flow<VolumeModification> =
    transform() { response ->
        response.volumesModifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumeStatusResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVolumeStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumeStatusResponse]
 */
fun Ec2Client.describeVolumeStatusPaginated(initialRequest: DescribeVolumeStatusRequest): Flow<DescribeVolumeStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumeStatusPaginated.describeVolumeStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVolumeStatusPaginated]
 * to access the nested member [VolumeStatusItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VolumeStatusItem]
 */
@JvmName("describeVolumeStatusResponseVolumeStatusItem")
fun Flow<DescribeVolumeStatusResponse>.volumeStatuses(): Flow<VolumeStatusItem> =
    transform() { response ->
        response.volumeStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcClassicLinkDnsSupportResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcClassicLinkDnsSupportRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcClassicLinkDnsSupportResponse]
 */
fun Ec2Client.describeVpcClassicLinkDnsSupportPaginated(initialRequest: DescribeVpcClassicLinkDnsSupportRequest): Flow<DescribeVpcClassicLinkDnsSupportResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcClassicLinkDnsSupportPaginated.describeVpcClassicLinkDnsSupport(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcClassicLinkDnsSupportPaginated]
 * to access the nested member [ClassicLinkDnsSupport]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClassicLinkDnsSupport]
 */
@JvmName("describeVpcClassicLinkDnsSupportResponseClassicLinkDnsSupport")
fun Flow<DescribeVpcClassicLinkDnsSupportResponse>.vpcs(): Flow<ClassicLinkDnsSupport> =
    transform() { response ->
        response.vpcs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionNotificationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcEndpointConnectionNotificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionNotificationsResponse]
 */
fun Ec2Client.describeVpcEndpointConnectionNotificationsPaginated(initialRequest: DescribeVpcEndpointConnectionNotificationsRequest): Flow<DescribeVpcEndpointConnectionNotificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointConnectionNotificationsPaginated.describeVpcEndpointConnectionNotifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcEndpointConnectionNotificationsPaginated]
 * to access the nested member [ConnectionNotification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ConnectionNotification]
 */
@JvmName("describeVpcEndpointConnectionNotificationsResponseConnectionNotification")
fun Flow<DescribeVpcEndpointConnectionNotificationsResponse>.connectionNotificationSet(): Flow<ConnectionNotification> =
    transform() { response ->
        response.connectionNotificationSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcEndpointConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionsResponse]
 */
fun Ec2Client.describeVpcEndpointConnectionsPaginated(initialRequest: DescribeVpcEndpointConnectionsRequest): Flow<DescribeVpcEndpointConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointConnectionsPaginated.describeVpcEndpointConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcEndpointConnectionsPaginated]
 * to access the nested member [VpcEndpointConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcEndpointConnection]
 */
@JvmName("describeVpcEndpointConnectionsResponseVpcEndpointConnection")
fun Flow<DescribeVpcEndpointConnectionsResponse>.vpcEndpointConnections(): Flow<VpcEndpointConnection> =
    transform() { response ->
        response.vpcEndpointConnections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcEndpointsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointsResponse]
 */
fun Ec2Client.describeVpcEndpointsPaginated(initialRequest: DescribeVpcEndpointsRequest): Flow<DescribeVpcEndpointsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointsPaginated.describeVpcEndpoints(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcEndpointsPaginated]
 * to access the nested member [VpcEndpoint]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcEndpoint]
 */
@JvmName("describeVpcEndpointsResponseVpcEndpoint")
fun Flow<DescribeVpcEndpointsResponse>.vpcEndpoints(): Flow<VpcEndpoint> =
    transform() { response ->
        response.vpcEndpoints?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServiceConfigurationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcEndpointServiceConfigurationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServiceConfigurationsResponse]
 */
fun Ec2Client.describeVpcEndpointServiceConfigurationsPaginated(initialRequest: DescribeVpcEndpointServiceConfigurationsRequest): Flow<DescribeVpcEndpointServiceConfigurationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointServiceConfigurationsPaginated.describeVpcEndpointServiceConfigurations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcEndpointServiceConfigurationsPaginated]
 * to access the nested member [ServiceConfiguration]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ServiceConfiguration]
 */
@JvmName("describeVpcEndpointServiceConfigurationsResponseServiceConfiguration")
fun Flow<DescribeVpcEndpointServiceConfigurationsResponse>.serviceConfigurations(): Flow<ServiceConfiguration> =
    transform() { response ->
        response.serviceConfigurations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServicePermissionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcEndpointServicePermissionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServicePermissionsResponse]
 */
fun Ec2Client.describeVpcEndpointServicePermissionsPaginated(initialRequest: DescribeVpcEndpointServicePermissionsRequest): Flow<DescribeVpcEndpointServicePermissionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointServicePermissionsPaginated.describeVpcEndpointServicePermissions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcEndpointServicePermissionsPaginated]
 * to access the nested member [AllowedPrincipal]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AllowedPrincipal]
 */
@JvmName("describeVpcEndpointServicePermissionsResponseAllowedPrincipal")
fun Flow<DescribeVpcEndpointServicePermissionsResponse>.allowedPrincipals(): Flow<AllowedPrincipal> =
    transform() { response ->
        response.allowedPrincipals?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcPeeringConnectionsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcPeeringConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcPeeringConnectionsResponse]
 */
fun Ec2Client.describeVpcPeeringConnectionsPaginated(initialRequest: DescribeVpcPeeringConnectionsRequest): Flow<DescribeVpcPeeringConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcPeeringConnectionsPaginated.describeVpcPeeringConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcPeeringConnectionsPaginated]
 * to access the nested member [VpcPeeringConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcPeeringConnection]
 */
@JvmName("describeVpcPeeringConnectionsResponseVpcPeeringConnection")
fun Flow<DescribeVpcPeeringConnectionsResponse>.vpcPeeringConnections(): Flow<VpcPeeringConnection> =
    transform() { response ->
        response.vpcPeeringConnections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [DescribeVpcsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcsResponse]
 */
fun Ec2Client.describeVpcsPaginated(initialRequest: DescribeVpcsRequest): Flow<DescribeVpcsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcsPaginated.describeVpcs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [describeVpcsPaginated]
 * to access the nested member [Vpc]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Vpc]
 */
@JvmName("describeVpcsResponseVpc")
fun Flow<DescribeVpcsResponse>.vpcs(): Flow<Vpc> =
    transform() { response ->
        response.vpcs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetAssociatedIpv6PoolCidrsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetAssociatedIpv6PoolCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetAssociatedIpv6PoolCidrsResponse]
 */
fun Ec2Client.getAssociatedIpv6PoolCidrsPaginated(initialRequest: GetAssociatedIpv6PoolCidrsRequest): Flow<GetAssociatedIpv6PoolCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getAssociatedIpv6PoolCidrsPaginated.getAssociatedIpv6PoolCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getAssociatedIpv6PoolCidrsPaginated]
 * to access the nested member [Ipv6CidrAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipv6CidrAssociation]
 */
@JvmName("getAssociatedIpv6PoolCidrsResponseIpv6CidrAssociation")
fun Flow<GetAssociatedIpv6PoolCidrsResponse>.ipv6CidrAssociations(): Flow<Ipv6CidrAssociation> =
    transform() { response ->
        response.ipv6CidrAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetGroupsForCapacityReservationResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetGroupsForCapacityReservationRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetGroupsForCapacityReservationResponse]
 */
fun Ec2Client.getGroupsForCapacityReservationPaginated(initialRequest: GetGroupsForCapacityReservationRequest): Flow<GetGroupsForCapacityReservationResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getGroupsForCapacityReservationPaginated.getGroupsForCapacityReservation(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getGroupsForCapacityReservationPaginated]
 * to access the nested member [CapacityReservationGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservationGroup]
 */
@JvmName("getGroupsForCapacityReservationResponseCapacityReservationGroup")
fun Flow<GetGroupsForCapacityReservationResponse>.capacityReservationGroups(): Flow<CapacityReservationGroup> =
    transform() { response ->
        response.capacityReservationGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetInstanceTypesFromInstanceRequirementsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetInstanceTypesFromInstanceRequirementsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetInstanceTypesFromInstanceRequirementsResponse]
 */
fun Ec2Client.getInstanceTypesFromInstanceRequirementsPaginated(initialRequest: GetInstanceTypesFromInstanceRequirementsRequest): Flow<GetInstanceTypesFromInstanceRequirementsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getInstanceTypesFromInstanceRequirementsPaginated.getInstanceTypesFromInstanceRequirements(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getInstanceTypesFromInstanceRequirementsPaginated]
 * to access the nested member [InstanceTypeInfoFromInstanceRequirements]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeInfoFromInstanceRequirements]
 */
@JvmName("getInstanceTypesFromInstanceRequirementsResponseInstanceTypeInfoFromInstanceRequirements")
fun Flow<GetInstanceTypesFromInstanceRequirementsResponse>.instanceTypes(): Flow<InstanceTypeInfoFromInstanceRequirements> =
    transform() { response ->
        response.instanceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamAddressHistoryResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetIpamAddressHistoryRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamAddressHistoryResponse]
 */
fun Ec2Client.getIpamAddressHistoryPaginated(initialRequest: GetIpamAddressHistoryRequest): Flow<GetIpamAddressHistoryResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamAddressHistoryPaginated.getIpamAddressHistory(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getIpamAddressHistoryPaginated]
 * to access the nested member [IpamAddressHistoryRecord]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamAddressHistoryRecord]
 */
@JvmName("getIpamAddressHistoryResponseIpamAddressHistoryRecord")
fun Flow<GetIpamAddressHistoryResponse>.historyRecords(): Flow<IpamAddressHistoryRecord> =
    transform() { response ->
        response.historyRecords?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamPoolAllocationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetIpamPoolAllocationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolAllocationsResponse]
 */
fun Ec2Client.getIpamPoolAllocationsPaginated(initialRequest: GetIpamPoolAllocationsRequest): Flow<GetIpamPoolAllocationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamPoolAllocationsPaginated.getIpamPoolAllocations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getIpamPoolAllocationsPaginated]
 * to access the nested member [IpamPoolAllocation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPoolAllocation]
 */
@JvmName("getIpamPoolAllocationsResponseIpamPoolAllocation")
fun Flow<GetIpamPoolAllocationsResponse>.ipamPoolAllocations(): Flow<IpamPoolAllocation> =
    transform() { response ->
        response.ipamPoolAllocations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamPoolCidrsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetIpamPoolCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolCidrsResponse]
 */
fun Ec2Client.getIpamPoolCidrsPaginated(initialRequest: GetIpamPoolCidrsRequest): Flow<GetIpamPoolCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamPoolCidrsPaginated.getIpamPoolCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getIpamPoolCidrsPaginated]
 * to access the nested member [IpamPoolCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPoolCidr]
 */
@JvmName("getIpamPoolCidrsResponseIpamPoolCidr")
fun Flow<GetIpamPoolCidrsResponse>.ipamPoolCidrs(): Flow<IpamPoolCidr> =
    transform() { response ->
        response.ipamPoolCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamResourceCidrsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetIpamResourceCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamResourceCidrsResponse]
 */
fun Ec2Client.getIpamResourceCidrsPaginated(initialRequest: GetIpamResourceCidrsRequest): Flow<GetIpamResourceCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamResourceCidrsPaginated.getIpamResourceCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getIpamResourceCidrsPaginated]
 * to access the nested member [IpamResourceCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamResourceCidr]
 */
@JvmName("getIpamResourceCidrsResponseIpamResourceCidr")
fun Flow<GetIpamResourceCidrsResponse>.ipamResourceCidrs(): Flow<IpamResourceCidr> =
    transform() { response ->
        response.ipamResourceCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetManagedPrefixListAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetManagedPrefixListAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListAssociationsResponse]
 */
fun Ec2Client.getManagedPrefixListAssociationsPaginated(initialRequest: GetManagedPrefixListAssociationsRequest): Flow<GetManagedPrefixListAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getManagedPrefixListAssociationsPaginated.getManagedPrefixListAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getManagedPrefixListAssociationsPaginated]
 * to access the nested member [PrefixListAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixListAssociation]
 */
@JvmName("getManagedPrefixListAssociationsResponsePrefixListAssociation")
fun Flow<GetManagedPrefixListAssociationsResponse>.prefixListAssociations(): Flow<PrefixListAssociation> =
    transform() { response ->
        response.prefixListAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetManagedPrefixListEntriesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetManagedPrefixListEntriesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListEntriesResponse]
 */
fun Ec2Client.getManagedPrefixListEntriesPaginated(initialRequest: GetManagedPrefixListEntriesRequest): Flow<GetManagedPrefixListEntriesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getManagedPrefixListEntriesPaginated.getManagedPrefixListEntries(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getManagedPrefixListEntriesPaginated]
 * to access the nested member [PrefixListEntry]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixListEntry]
 */
@JvmName("getManagedPrefixListEntriesResponsePrefixListEntry")
fun Flow<GetManagedPrefixListEntriesResponse>.entries(): Flow<PrefixListEntry> =
    transform() { response ->
        response.entries?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetSpotPlacementScoresResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetSpotPlacementScoresRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetSpotPlacementScoresResponse]
 */
fun Ec2Client.getSpotPlacementScoresPaginated(initialRequest: GetSpotPlacementScoresRequest): Flow<GetSpotPlacementScoresResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getSpotPlacementScoresPaginated.getSpotPlacementScores(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getSpotPlacementScoresPaginated]
 * to access the nested member [SpotPlacementScore]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotPlacementScore]
 */
@JvmName("getSpotPlacementScoresResponseSpotPlacementScore")
fun Flow<GetSpotPlacementScoresResponse>.spotPlacementScores(): Flow<SpotPlacementScore> =
    transform() { response ->
        response.spotPlacementScores?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayAttachmentPropagationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetTransitGatewayAttachmentPropagationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayAttachmentPropagationsResponse]
 */
fun Ec2Client.getTransitGatewayAttachmentPropagationsPaginated(initialRequest: GetTransitGatewayAttachmentPropagationsRequest): Flow<GetTransitGatewayAttachmentPropagationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayAttachmentPropagationsPaginated.getTransitGatewayAttachmentPropagations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getTransitGatewayAttachmentPropagationsPaginated]
 * to access the nested member [TransitGatewayAttachmentPropagation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayAttachmentPropagation]
 */
@JvmName("getTransitGatewayAttachmentPropagationsResponseTransitGatewayAttachmentPropagation")
fun Flow<GetTransitGatewayAttachmentPropagationsResponse>.transitGatewayAttachmentPropagations(): Flow<TransitGatewayAttachmentPropagation> =
    transform() { response ->
        response.transitGatewayAttachmentPropagations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayMulticastDomainAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetTransitGatewayMulticastDomainAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayMulticastDomainAssociationsResponse]
 */
fun Ec2Client.getTransitGatewayMulticastDomainAssociationsPaginated(initialRequest: GetTransitGatewayMulticastDomainAssociationsRequest): Flow<GetTransitGatewayMulticastDomainAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayMulticastDomainAssociationsPaginated.getTransitGatewayMulticastDomainAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getTransitGatewayMulticastDomainAssociationsPaginated]
 * to access the nested member [TransitGatewayMulticastDomainAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastDomainAssociation]
 */
@JvmName("getTransitGatewayMulticastDomainAssociationsResponseTransitGatewayMulticastDomainAssociation")
fun Flow<GetTransitGatewayMulticastDomainAssociationsResponse>.multicastDomainAssociations(): Flow<TransitGatewayMulticastDomainAssociation> =
    transform() { response ->
        response.multicastDomainAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayPrefixListReferencesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetTransitGatewayPrefixListReferencesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayPrefixListReferencesResponse]
 */
fun Ec2Client.getTransitGatewayPrefixListReferencesPaginated(initialRequest: GetTransitGatewayPrefixListReferencesRequest): Flow<GetTransitGatewayPrefixListReferencesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayPrefixListReferencesPaginated.getTransitGatewayPrefixListReferences(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getTransitGatewayPrefixListReferencesPaginated]
 * to access the nested member [TransitGatewayPrefixListReference]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPrefixListReference]
 */
@JvmName("getTransitGatewayPrefixListReferencesResponseTransitGatewayPrefixListReference")
fun Flow<GetTransitGatewayPrefixListReferencesResponse>.transitGatewayPrefixListReferences(): Flow<TransitGatewayPrefixListReference> =
    transform() { response ->
        response.transitGatewayPrefixListReferences?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTableAssociationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetTransitGatewayRouteTableAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTableAssociationsResponse]
 */
fun Ec2Client.getTransitGatewayRouteTableAssociationsPaginated(initialRequest: GetTransitGatewayRouteTableAssociationsRequest): Flow<GetTransitGatewayRouteTableAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayRouteTableAssociationsPaginated.getTransitGatewayRouteTableAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getTransitGatewayRouteTableAssociationsPaginated]
 * to access the nested member [TransitGatewayRouteTableAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTableAssociation]
 */
@JvmName("getTransitGatewayRouteTableAssociationsResponseTransitGatewayRouteTableAssociation")
fun Flow<GetTransitGatewayRouteTableAssociationsResponse>.associations(): Flow<TransitGatewayRouteTableAssociation> =
    transform() { response ->
        response.associations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTablePropagationsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetTransitGatewayRouteTablePropagationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTablePropagationsResponse]
 */
fun Ec2Client.getTransitGatewayRouteTablePropagationsPaginated(initialRequest: GetTransitGatewayRouteTablePropagationsRequest): Flow<GetTransitGatewayRouteTablePropagationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayRouteTablePropagationsPaginated.getTransitGatewayRouteTablePropagations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getTransitGatewayRouteTablePropagationsPaginated]
 * to access the nested member [TransitGatewayRouteTablePropagation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTablePropagation]
 */
@JvmName("getTransitGatewayRouteTablePropagationsResponseTransitGatewayRouteTablePropagation")
fun Flow<GetTransitGatewayRouteTablePropagationsResponse>.transitGatewayRouteTablePropagations(): Flow<TransitGatewayRouteTablePropagation> =
    transform() { response ->
        response.transitGatewayRouteTablePropagations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetVpnConnectionDeviceTypesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [GetVpnConnectionDeviceTypesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetVpnConnectionDeviceTypesResponse]
 */
fun Ec2Client.getVpnConnectionDeviceTypesPaginated(initialRequest: GetVpnConnectionDeviceTypesRequest): Flow<GetVpnConnectionDeviceTypesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getVpnConnectionDeviceTypesPaginated.getVpnConnectionDeviceTypes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [getVpnConnectionDeviceTypesPaginated]
 * to access the nested member [VpnConnectionDeviceType]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpnConnectionDeviceType]
 */
@JvmName("getVpnConnectionDeviceTypesResponseVpnConnectionDeviceType")
fun Flow<GetVpnConnectionDeviceTypesResponse>.vpnConnectionDeviceTypes(): Flow<VpnConnectionDeviceType> =
    transform() { response ->
        response.vpnConnectionDeviceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [ListSnapshotsInRecycleBinResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [ListSnapshotsInRecycleBinRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ListSnapshotsInRecycleBinResponse]
 */
fun Ec2Client.listSnapshotsInRecycleBinPaginated(initialRequest: ListSnapshotsInRecycleBinRequest): Flow<ListSnapshotsInRecycleBinResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@listSnapshotsInRecycleBinPaginated.listSnapshotsInRecycleBin(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [listSnapshotsInRecycleBinPaginated]
 * to access the nested member [SnapshotRecycleBinInfo]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SnapshotRecycleBinInfo]
 */
@JvmName("listSnapshotsInRecycleBinResponseSnapshotRecycleBinInfo")
fun Flow<ListSnapshotsInRecycleBinResponse>.snapshots(): Flow<SnapshotRecycleBinInfo> =
    transform() { response ->
        response.snapshots?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [SearchLocalGatewayRoutesResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [SearchLocalGatewayRoutesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchLocalGatewayRoutesResponse]
 */
fun Ec2Client.searchLocalGatewayRoutesPaginated(initialRequest: SearchLocalGatewayRoutesRequest): Flow<SearchLocalGatewayRoutesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@searchLocalGatewayRoutesPaginated.searchLocalGatewayRoutes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [searchLocalGatewayRoutesPaginated]
 * to access the nested member [LocalGatewayRoute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRoute]
 */
@JvmName("searchLocalGatewayRoutesResponseLocalGatewayRoute")
fun Flow<SearchLocalGatewayRoutesResponse>.routes(): Flow<LocalGatewayRoute> =
    transform() { response ->
        response.routes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [SearchTransitGatewayMulticastGroupsResponse] results.
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service calls are
 * made until the flow is collected. This also means there is no guarantee that the request is valid until then. Once
 * you start collecting the flow, the SDK will lazily load response pages by making service calls until there are no
 * pages left or the flow is cancelled. If there are errors in your request, you will see the failures only after you start
 * collection.
 * @param initialRequest A [SearchTransitGatewayMulticastGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchTransitGatewayMulticastGroupsResponse]
 */
fun Ec2Client.searchTransitGatewayMulticastGroupsPaginated(initialRequest: SearchTransitGatewayMulticastGroupsRequest): Flow<SearchTransitGatewayMulticastGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@searchTransitGatewayMulticastGroupsPaginated.searchTransitGatewayMulticastGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * This paginator transforms the flow returned by [searchTransitGatewayMulticastGroupsPaginated]
 * to access the nested member [TransitGatewayMulticastGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastGroup]
 */
@JvmName("searchTransitGatewayMulticastGroupsResponseTransitGatewayMulticastGroup")
fun Flow<SearchTransitGatewayMulticastGroupsResponse>.multicastGroups(): Flow<TransitGatewayMulticastGroup> =
    transform() { response ->
        response.multicastGroups?.forEach {
            emit(it)
        }
    }
