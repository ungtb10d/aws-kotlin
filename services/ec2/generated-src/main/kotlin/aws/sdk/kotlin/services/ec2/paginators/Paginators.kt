// Code generated by smithy-kotlin-codegen. DO NOT EDIT!

package aws.sdk.kotlin.services.ec2.paginators

import aws.sdk.kotlin.services.ec2.Ec2Client
import aws.sdk.kotlin.services.ec2.model.AddressAttribute
import aws.sdk.kotlin.services.ec2.model.AllowedPrincipal
import aws.sdk.kotlin.services.ec2.model.AuthorizationRule
import aws.sdk.kotlin.services.ec2.model.ByoipCidr
import aws.sdk.kotlin.services.ec2.model.CapacityReservation
import aws.sdk.kotlin.services.ec2.model.CapacityReservationFleet
import aws.sdk.kotlin.services.ec2.model.CapacityReservationGroup
import aws.sdk.kotlin.services.ec2.model.CarrierGateway
import aws.sdk.kotlin.services.ec2.model.ClassicLinkDnsSupport
import aws.sdk.kotlin.services.ec2.model.ClassicLinkInstance
import aws.sdk.kotlin.services.ec2.model.ClientVpnConnection
import aws.sdk.kotlin.services.ec2.model.ClientVpnEndpoint
import aws.sdk.kotlin.services.ec2.model.ClientVpnRoute
import aws.sdk.kotlin.services.ec2.model.CoipPool
import aws.sdk.kotlin.services.ec2.model.ConnectionNotification
import aws.sdk.kotlin.services.ec2.model.DescribeAddressesAttributeRequest
import aws.sdk.kotlin.services.ec2.model.DescribeAddressesAttributeResponse
import aws.sdk.kotlin.services.ec2.model.DescribeByoipCidrsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeByoipCidrsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationFleetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationFleetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCapacityReservationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCarrierGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCarrierGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClassicLinkInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClassicLinkInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnAuthorizationRulesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnAuthorizationRulesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnEndpointsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnEndpointsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnRoutesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnRoutesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnTargetNetworksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeClientVpnTargetNetworksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeCoipPoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeCoipPoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeDhcpOptionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeDhcpOptionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeEgressOnlyInternetGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeEgressOnlyInternetGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeExportImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeExportImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFastLaunchImagesSuccessItem
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoreSuccessItem
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoresRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFastSnapshotRestoresResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFleetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFleetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFlowLogsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFlowLogsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeFpgaImagesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeFpgaImagesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostReservationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeHostsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeHostsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIamInstanceProfileAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIamInstanceProfileAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeImportImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeImportImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeImportSnapshotTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeImportSnapshotTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceCreditSpecificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceCreditSpecificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceEventWindowsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceEventWindowsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypeOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypeOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstanceTypesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeInternetGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeInternetGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamPoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamPoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamScopesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamScopesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpamsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpamsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeIpv6PoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeIpv6PoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplateVersionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplateVersionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplatesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLaunchTemplatesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVpcAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTableVpcAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfaceGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfaceGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfacesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewayVirtualInterfacesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeLocalGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeManagedPrefixListsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeManagedPrefixListsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeMovingAddressesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeMovingAddressesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNatGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNatGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkAclsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkAclsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopeAnalysesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopeAnalysesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAccessScopesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAnalysesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsAnalysesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsPathsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInsightsPathsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacePermissionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacePermissionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeNetworkInterfacesResponse
import aws.sdk.kotlin.services.ec2.model.DescribePrefixListsRequest
import aws.sdk.kotlin.services.ec2.model.DescribePrefixListsResponse
import aws.sdk.kotlin.services.ec2.model.DescribePrincipalIdFormatRequest
import aws.sdk.kotlin.services.ec2.model.DescribePrincipalIdFormatResponse
import aws.sdk.kotlin.services.ec2.model.DescribePublicIpv4PoolsRequest
import aws.sdk.kotlin.services.ec2.model.DescribePublicIpv4PoolsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReplaceRootVolumeTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReplaceRootVolumeTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesModificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesModificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesOfferingsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeReservedInstancesOfferingsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstanceAvailabilityRequest
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstanceAvailabilityResponse
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstancesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeScheduledInstancesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupRulesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupRulesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSecurityGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotTierStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotTierStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSnapshotsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotFleetRequestsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotFleetRequestsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotInstanceRequestsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotInstanceRequestsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSpotPriceHistoryRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSpotPriceHistoryResponse
import aws.sdk.kotlin.services.ec2.model.DescribeStaleSecurityGroupsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeStaleSecurityGroupsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeStoreImageTasksRequest
import aws.sdk.kotlin.services.ec2.model.DescribeStoreImageTasksResponse
import aws.sdk.kotlin.services.ec2.model.DescribeSubnetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeSubnetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTagsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTagsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorFiltersRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorFiltersResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorSessionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorSessionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorTargetsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrafficMirrorTargetsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectPeersRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectPeersResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayConnectsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayMulticastDomainsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayMulticastDomainsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPeeringAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPeeringAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPolicyTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayPolicyTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTableAnnouncementsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTableAnnouncementsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTablesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayRouteTablesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayVpcAttachmentsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewayVpcAttachmentsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewaysRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTransitGatewaysResponse
import aws.sdk.kotlin.services.ec2.model.DescribeTrunkInterfaceAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeTrunkInterfaceAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumeStatusRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumeStatusResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesModificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesModificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVolumesResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcClassicLinkDnsSupportRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcClassicLinkDnsSupportResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionNotificationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionNotificationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServiceConfigurationsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServiceConfigurationsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServicePermissionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointServicePermissionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcEndpointsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcPeeringConnectionsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcPeeringConnectionsResponse
import aws.sdk.kotlin.services.ec2.model.DescribeVpcsRequest
import aws.sdk.kotlin.services.ec2.model.DescribeVpcsResponse
import aws.sdk.kotlin.services.ec2.model.DhcpOptions
import aws.sdk.kotlin.services.ec2.model.EgressOnlyInternetGateway
import aws.sdk.kotlin.services.ec2.model.ExportImageTask
import aws.sdk.kotlin.services.ec2.model.FleetData
import aws.sdk.kotlin.services.ec2.model.FlowLog
import aws.sdk.kotlin.services.ec2.model.FpgaImage
import aws.sdk.kotlin.services.ec2.model.GetAssociatedIpv6PoolCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetAssociatedIpv6PoolCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetGroupsForCapacityReservationRequest
import aws.sdk.kotlin.services.ec2.model.GetGroupsForCapacityReservationResponse
import aws.sdk.kotlin.services.ec2.model.GetInstanceTypesFromInstanceRequirementsRequest
import aws.sdk.kotlin.services.ec2.model.GetInstanceTypesFromInstanceRequirementsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamAddressHistoryRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamAddressHistoryResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolAllocationsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolAllocationsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamPoolCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetIpamResourceCidrsRequest
import aws.sdk.kotlin.services.ec2.model.GetIpamResourceCidrsResponse
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListEntriesRequest
import aws.sdk.kotlin.services.ec2.model.GetManagedPrefixListEntriesResponse
import aws.sdk.kotlin.services.ec2.model.GetSpotPlacementScoresRequest
import aws.sdk.kotlin.services.ec2.model.GetSpotPlacementScoresResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayAttachmentPropagationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayAttachmentPropagationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayMulticastDomainAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayMulticastDomainAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPolicyTableAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPolicyTableAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPrefixListReferencesRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayPrefixListReferencesResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTableAssociationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTableAssociationsResponse
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTablePropagationsRequest
import aws.sdk.kotlin.services.ec2.model.GetTransitGatewayRouteTablePropagationsResponse
import aws.sdk.kotlin.services.ec2.model.GetVpnConnectionDeviceTypesRequest
import aws.sdk.kotlin.services.ec2.model.GetVpnConnectionDeviceTypesResponse
import aws.sdk.kotlin.services.ec2.model.Host
import aws.sdk.kotlin.services.ec2.model.HostOffering
import aws.sdk.kotlin.services.ec2.model.HostReservation
import aws.sdk.kotlin.services.ec2.model.IamInstanceProfileAssociation
import aws.sdk.kotlin.services.ec2.model.ImageRecycleBinInfo
import aws.sdk.kotlin.services.ec2.model.ImportImageTask
import aws.sdk.kotlin.services.ec2.model.ImportSnapshotTask
import aws.sdk.kotlin.services.ec2.model.InstanceCreditSpecification
import aws.sdk.kotlin.services.ec2.model.InstanceEventWindow
import aws.sdk.kotlin.services.ec2.model.InstanceStatus
import aws.sdk.kotlin.services.ec2.model.InstanceTypeInfo
import aws.sdk.kotlin.services.ec2.model.InstanceTypeInfoFromInstanceRequirements
import aws.sdk.kotlin.services.ec2.model.InstanceTypeOffering
import aws.sdk.kotlin.services.ec2.model.InternetGateway
import aws.sdk.kotlin.services.ec2.model.Ipam
import aws.sdk.kotlin.services.ec2.model.IpamAddressHistoryRecord
import aws.sdk.kotlin.services.ec2.model.IpamPool
import aws.sdk.kotlin.services.ec2.model.IpamPoolAllocation
import aws.sdk.kotlin.services.ec2.model.IpamPoolCidr
import aws.sdk.kotlin.services.ec2.model.IpamResourceCidr
import aws.sdk.kotlin.services.ec2.model.IpamScope
import aws.sdk.kotlin.services.ec2.model.Ipv6CidrAssociation
import aws.sdk.kotlin.services.ec2.model.Ipv6Pool
import aws.sdk.kotlin.services.ec2.model.LaunchTemplate
import aws.sdk.kotlin.services.ec2.model.LaunchTemplateVersion
import aws.sdk.kotlin.services.ec2.model.ListImagesInRecycleBinRequest
import aws.sdk.kotlin.services.ec2.model.ListImagesInRecycleBinResponse
import aws.sdk.kotlin.services.ec2.model.ListSnapshotsInRecycleBinRequest
import aws.sdk.kotlin.services.ec2.model.ListSnapshotsInRecycleBinResponse
import aws.sdk.kotlin.services.ec2.model.LocalGateway
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRoute
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTable
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTableVirtualInterfaceGroupAssociation
import aws.sdk.kotlin.services.ec2.model.LocalGatewayRouteTableVpcAssociation
import aws.sdk.kotlin.services.ec2.model.LocalGatewayVirtualInterface
import aws.sdk.kotlin.services.ec2.model.LocalGatewayVirtualInterfaceGroup
import aws.sdk.kotlin.services.ec2.model.ManagedPrefixList
import aws.sdk.kotlin.services.ec2.model.MovingAddressStatus
import aws.sdk.kotlin.services.ec2.model.NatGateway
import aws.sdk.kotlin.services.ec2.model.NetworkAcl
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAccessScope
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAccessScopeAnalysis
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsAnalysis
import aws.sdk.kotlin.services.ec2.model.NetworkInsightsPath
import aws.sdk.kotlin.services.ec2.model.NetworkInterface
import aws.sdk.kotlin.services.ec2.model.NetworkInterfacePermission
import aws.sdk.kotlin.services.ec2.model.PrefixList
import aws.sdk.kotlin.services.ec2.model.PrefixListAssociation
import aws.sdk.kotlin.services.ec2.model.PrefixListEntry
import aws.sdk.kotlin.services.ec2.model.PrincipalIdFormat
import aws.sdk.kotlin.services.ec2.model.PublicIpv4Pool
import aws.sdk.kotlin.services.ec2.model.ReplaceRootVolumeTask
import aws.sdk.kotlin.services.ec2.model.Reservation
import aws.sdk.kotlin.services.ec2.model.ReservedInstancesModification
import aws.sdk.kotlin.services.ec2.model.ReservedInstancesOffering
import aws.sdk.kotlin.services.ec2.model.RouteTable
import aws.sdk.kotlin.services.ec2.model.ScheduledInstance
import aws.sdk.kotlin.services.ec2.model.ScheduledInstanceAvailability
import aws.sdk.kotlin.services.ec2.model.SearchLocalGatewayRoutesRequest
import aws.sdk.kotlin.services.ec2.model.SearchLocalGatewayRoutesResponse
import aws.sdk.kotlin.services.ec2.model.SearchTransitGatewayMulticastGroupsRequest
import aws.sdk.kotlin.services.ec2.model.SearchTransitGatewayMulticastGroupsResponse
import aws.sdk.kotlin.services.ec2.model.SecurityGroup
import aws.sdk.kotlin.services.ec2.model.SecurityGroupRule
import aws.sdk.kotlin.services.ec2.model.ServiceConfiguration
import aws.sdk.kotlin.services.ec2.model.Snapshot
import aws.sdk.kotlin.services.ec2.model.SnapshotRecycleBinInfo
import aws.sdk.kotlin.services.ec2.model.SnapshotTierStatus
import aws.sdk.kotlin.services.ec2.model.SpotFleetRequestConfig
import aws.sdk.kotlin.services.ec2.model.SpotInstanceRequest
import aws.sdk.kotlin.services.ec2.model.SpotPlacementScore
import aws.sdk.kotlin.services.ec2.model.SpotPrice
import aws.sdk.kotlin.services.ec2.model.StaleSecurityGroup
import aws.sdk.kotlin.services.ec2.model.StoreImageTaskResult
import aws.sdk.kotlin.services.ec2.model.Subnet
import aws.sdk.kotlin.services.ec2.model.TagDescription
import aws.sdk.kotlin.services.ec2.model.TargetNetwork
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorFilter
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorSession
import aws.sdk.kotlin.services.ec2.model.TrafficMirrorTarget
import aws.sdk.kotlin.services.ec2.model.TransitGateway
import aws.sdk.kotlin.services.ec2.model.TransitGatewayAttachment
import aws.sdk.kotlin.services.ec2.model.TransitGatewayAttachmentPropagation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayConnect
import aws.sdk.kotlin.services.ec2.model.TransitGatewayConnectPeer
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastDomain
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastDomainAssociation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayMulticastGroup
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPeeringAttachment
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPolicyTable
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPolicyTableAssociation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayPrefixListReference
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTable
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTableAnnouncement
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTableAssociation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayRouteTablePropagation
import aws.sdk.kotlin.services.ec2.model.TransitGatewayVpcAttachment
import aws.sdk.kotlin.services.ec2.model.TrunkInterfaceAssociation
import aws.sdk.kotlin.services.ec2.model.Volume
import aws.sdk.kotlin.services.ec2.model.VolumeModification
import aws.sdk.kotlin.services.ec2.model.VolumeStatusItem
import aws.sdk.kotlin.services.ec2.model.Vpc
import aws.sdk.kotlin.services.ec2.model.VpcEndpoint
import aws.sdk.kotlin.services.ec2.model.VpcEndpointConnection
import aws.sdk.kotlin.services.ec2.model.VpcPeeringConnection
import aws.sdk.kotlin.services.ec2.model.VpnConnectionDeviceType
import kotlin.jvm.JvmName
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import kotlinx.coroutines.flow.transform


/**
 * Paginate over [DescribeAddressesAttributeResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeAddressesAttributeRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeAddressesAttributeResponse]
 */
public fun Ec2Client.describeAddressesAttributePaginated(initialRequest: DescribeAddressesAttributeRequest): Flow<DescribeAddressesAttributeResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeAddressesAttributePaginated.describeAddressesAttribute(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeAddressesAttributeResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeAddressesAttributeResponse]
 */
public fun Ec2Client.describeAddressesAttributePaginated(block: DescribeAddressesAttributeRequest.Builder.() -> Unit): Flow<DescribeAddressesAttributeResponse> =
    describeAddressesAttributePaginated(DescribeAddressesAttributeRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeAddressesAttributePaginated]
 * to access the nested member [AddressAttribute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AddressAttribute]
 */
@JvmName("describeAddressesAttributeResponseAddressAttribute")
public fun Flow<DescribeAddressesAttributeResponse>.addresses(): Flow<AddressAttribute> =
    transform() { response ->
        response.addresses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeByoipCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeByoipCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeByoipCidrsResponse]
 */
public fun Ec2Client.describeByoipCidrsPaginated(initialRequest: DescribeByoipCidrsRequest): Flow<DescribeByoipCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeByoipCidrsPaginated.describeByoipCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeByoipCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeByoipCidrsResponse]
 */
public fun Ec2Client.describeByoipCidrsPaginated(block: DescribeByoipCidrsRequest.Builder.() -> Unit): Flow<DescribeByoipCidrsResponse> =
    describeByoipCidrsPaginated(DescribeByoipCidrsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeByoipCidrsPaginated]
 * to access the nested member [ByoipCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ByoipCidr]
 */
@JvmName("describeByoipCidrsResponseByoipCidr")
public fun Flow<DescribeByoipCidrsResponse>.byoipCidrs(): Flow<ByoipCidr> =
    transform() { response ->
        response.byoipCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationFleetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeCapacityReservationFleetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationFleetsResponse]
 */
public fun Ec2Client.describeCapacityReservationFleetsPaginated(initialRequest: DescribeCapacityReservationFleetsRequest): Flow<DescribeCapacityReservationFleetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCapacityReservationFleetsPaginated.describeCapacityReservationFleets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationFleetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationFleetsResponse]
 */
public fun Ec2Client.describeCapacityReservationFleetsPaginated(block: DescribeCapacityReservationFleetsRequest.Builder.() -> Unit): Flow<DescribeCapacityReservationFleetsResponse> =
    describeCapacityReservationFleetsPaginated(DescribeCapacityReservationFleetsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeCapacityReservationFleetsPaginated]
 * to access the nested member [CapacityReservationFleet]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservationFleet]
 */
@JvmName("describeCapacityReservationFleetsResponseCapacityReservationFleet")
public fun Flow<DescribeCapacityReservationFleetsResponse>.capacityReservationFleets(): Flow<CapacityReservationFleet> =
    transform() { response ->
        response.capacityReservationFleets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeCapacityReservationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationsResponse]
 */
public fun Ec2Client.describeCapacityReservationsPaginated(initialRequest: DescribeCapacityReservationsRequest): Flow<DescribeCapacityReservationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCapacityReservationsPaginated.describeCapacityReservations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeCapacityReservationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCapacityReservationsResponse]
 */
public fun Ec2Client.describeCapacityReservationsPaginated(block: DescribeCapacityReservationsRequest.Builder.() -> Unit): Flow<DescribeCapacityReservationsResponse> =
    describeCapacityReservationsPaginated(DescribeCapacityReservationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeCapacityReservationsPaginated]
 * to access the nested member [CapacityReservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservation]
 */
@JvmName("describeCapacityReservationsResponseCapacityReservation")
public fun Flow<DescribeCapacityReservationsResponse>.capacityReservations(): Flow<CapacityReservation> =
    transform() { response ->
        response.capacityReservations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCarrierGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeCarrierGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCarrierGatewaysResponse]
 */
public fun Ec2Client.describeCarrierGatewaysPaginated(initialRequest: DescribeCarrierGatewaysRequest): Flow<DescribeCarrierGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCarrierGatewaysPaginated.describeCarrierGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeCarrierGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCarrierGatewaysResponse]
 */
public fun Ec2Client.describeCarrierGatewaysPaginated(block: DescribeCarrierGatewaysRequest.Builder.() -> Unit): Flow<DescribeCarrierGatewaysResponse> =
    describeCarrierGatewaysPaginated(DescribeCarrierGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeCarrierGatewaysPaginated]
 * to access the nested member [CarrierGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CarrierGateway]
 */
@JvmName("describeCarrierGatewaysResponseCarrierGateway")
public fun Flow<DescribeCarrierGatewaysResponse>.carrierGateways(): Flow<CarrierGateway> =
    transform() { response ->
        response.carrierGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClassicLinkInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClassicLinkInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClassicLinkInstancesResponse]
 */
public fun Ec2Client.describeClassicLinkInstancesPaginated(initialRequest: DescribeClassicLinkInstancesRequest): Flow<DescribeClassicLinkInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClassicLinkInstancesPaginated.describeClassicLinkInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClassicLinkInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClassicLinkInstancesResponse]
 */
public fun Ec2Client.describeClassicLinkInstancesPaginated(block: DescribeClassicLinkInstancesRequest.Builder.() -> Unit): Flow<DescribeClassicLinkInstancesResponse> =
    describeClassicLinkInstancesPaginated(DescribeClassicLinkInstancesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClassicLinkInstancesPaginated]
 * to access the nested member [ClassicLinkInstance]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClassicLinkInstance]
 */
@JvmName("describeClassicLinkInstancesResponseClassicLinkInstance")
public fun Flow<DescribeClassicLinkInstancesResponse>.instances(): Flow<ClassicLinkInstance> =
    transform() { response ->
        response.instances?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnAuthorizationRulesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClientVpnAuthorizationRulesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnAuthorizationRulesResponse]
 */
public fun Ec2Client.describeClientVpnAuthorizationRulesPaginated(initialRequest: DescribeClientVpnAuthorizationRulesRequest): Flow<DescribeClientVpnAuthorizationRulesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnAuthorizationRulesPaginated.describeClientVpnAuthorizationRules(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClientVpnAuthorizationRulesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnAuthorizationRulesResponse]
 */
public fun Ec2Client.describeClientVpnAuthorizationRulesPaginated(block: DescribeClientVpnAuthorizationRulesRequest.Builder.() -> Unit): Flow<DescribeClientVpnAuthorizationRulesResponse> =
    describeClientVpnAuthorizationRulesPaginated(DescribeClientVpnAuthorizationRulesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClientVpnAuthorizationRulesPaginated]
 * to access the nested member [AuthorizationRule]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AuthorizationRule]
 */
@JvmName("describeClientVpnAuthorizationRulesResponseAuthorizationRule")
public fun Flow<DescribeClientVpnAuthorizationRulesResponse>.authorizationRules(): Flow<AuthorizationRule> =
    transform() { response ->
        response.authorizationRules?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClientVpnConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnConnectionsResponse]
 */
public fun Ec2Client.describeClientVpnConnectionsPaginated(initialRequest: DescribeClientVpnConnectionsRequest): Flow<DescribeClientVpnConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnConnectionsPaginated.describeClientVpnConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClientVpnConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnConnectionsResponse]
 */
public fun Ec2Client.describeClientVpnConnectionsPaginated(block: DescribeClientVpnConnectionsRequest.Builder.() -> Unit): Flow<DescribeClientVpnConnectionsResponse> =
    describeClientVpnConnectionsPaginated(DescribeClientVpnConnectionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClientVpnConnectionsPaginated]
 * to access the nested member [ClientVpnConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnConnection]
 */
@JvmName("describeClientVpnConnectionsResponseClientVpnConnection")
public fun Flow<DescribeClientVpnConnectionsResponse>.connections(): Flow<ClientVpnConnection> =
    transform() { response ->
        response.connections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnEndpointsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClientVpnEndpointsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnEndpointsResponse]
 */
public fun Ec2Client.describeClientVpnEndpointsPaginated(initialRequest: DescribeClientVpnEndpointsRequest): Flow<DescribeClientVpnEndpointsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnEndpointsPaginated.describeClientVpnEndpoints(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClientVpnEndpointsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnEndpointsResponse]
 */
public fun Ec2Client.describeClientVpnEndpointsPaginated(block: DescribeClientVpnEndpointsRequest.Builder.() -> Unit): Flow<DescribeClientVpnEndpointsResponse> =
    describeClientVpnEndpointsPaginated(DescribeClientVpnEndpointsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClientVpnEndpointsPaginated]
 * to access the nested member [ClientVpnEndpoint]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnEndpoint]
 */
@JvmName("describeClientVpnEndpointsResponseClientVpnEndpoint")
public fun Flow<DescribeClientVpnEndpointsResponse>.clientVpnEndpoints(): Flow<ClientVpnEndpoint> =
    transform() { response ->
        response.clientVpnEndpoints?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnRoutesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClientVpnRoutesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnRoutesResponse]
 */
public fun Ec2Client.describeClientVpnRoutesPaginated(initialRequest: DescribeClientVpnRoutesRequest): Flow<DescribeClientVpnRoutesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnRoutesPaginated.describeClientVpnRoutes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClientVpnRoutesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnRoutesResponse]
 */
public fun Ec2Client.describeClientVpnRoutesPaginated(block: DescribeClientVpnRoutesRequest.Builder.() -> Unit): Flow<DescribeClientVpnRoutesResponse> =
    describeClientVpnRoutesPaginated(DescribeClientVpnRoutesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClientVpnRoutesPaginated]
 * to access the nested member [ClientVpnRoute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClientVpnRoute]
 */
@JvmName("describeClientVpnRoutesResponseClientVpnRoute")
public fun Flow<DescribeClientVpnRoutesResponse>.routes(): Flow<ClientVpnRoute> =
    transform() { response ->
        response.routes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeClientVpnTargetNetworksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeClientVpnTargetNetworksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnTargetNetworksResponse]
 */
public fun Ec2Client.describeClientVpnTargetNetworksPaginated(initialRequest: DescribeClientVpnTargetNetworksRequest): Flow<DescribeClientVpnTargetNetworksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeClientVpnTargetNetworksPaginated.describeClientVpnTargetNetworks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeClientVpnTargetNetworksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeClientVpnTargetNetworksResponse]
 */
public fun Ec2Client.describeClientVpnTargetNetworksPaginated(block: DescribeClientVpnTargetNetworksRequest.Builder.() -> Unit): Flow<DescribeClientVpnTargetNetworksResponse> =
    describeClientVpnTargetNetworksPaginated(DescribeClientVpnTargetNetworksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeClientVpnTargetNetworksPaginated]
 * to access the nested member [TargetNetwork]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TargetNetwork]
 */
@JvmName("describeClientVpnTargetNetworksResponseTargetNetwork")
public fun Flow<DescribeClientVpnTargetNetworksResponse>.clientVpnTargetNetworks(): Flow<TargetNetwork> =
    transform() { response ->
        response.clientVpnTargetNetworks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeCoipPoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeCoipPoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCoipPoolsResponse]
 */
public fun Ec2Client.describeCoipPoolsPaginated(initialRequest: DescribeCoipPoolsRequest): Flow<DescribeCoipPoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeCoipPoolsPaginated.describeCoipPools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeCoipPoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeCoipPoolsResponse]
 */
public fun Ec2Client.describeCoipPoolsPaginated(block: DescribeCoipPoolsRequest.Builder.() -> Unit): Flow<DescribeCoipPoolsResponse> =
    describeCoipPoolsPaginated(DescribeCoipPoolsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeCoipPoolsPaginated]
 * to access the nested member [CoipPool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CoipPool]
 */
@JvmName("describeCoipPoolsResponseCoipPool")
public fun Flow<DescribeCoipPoolsResponse>.coipPools(): Flow<CoipPool> =
    transform() { response ->
        response.coipPools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeDhcpOptionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeDhcpOptionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeDhcpOptionsResponse]
 */
public fun Ec2Client.describeDhcpOptionsPaginated(initialRequest: DescribeDhcpOptionsRequest): Flow<DescribeDhcpOptionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeDhcpOptionsPaginated.describeDhcpOptions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeDhcpOptionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeDhcpOptionsResponse]
 */
public fun Ec2Client.describeDhcpOptionsPaginated(block: DescribeDhcpOptionsRequest.Builder.() -> Unit): Flow<DescribeDhcpOptionsResponse> =
    describeDhcpOptionsPaginated(DescribeDhcpOptionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeDhcpOptionsPaginated]
 * to access the nested member [DhcpOptions]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DhcpOptions]
 */
@JvmName("describeDhcpOptionsResponseDhcpOptions")
public fun Flow<DescribeDhcpOptionsResponse>.dhcpOptions(): Flow<DhcpOptions> =
    transform() { response ->
        response.dhcpOptions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeEgressOnlyInternetGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeEgressOnlyInternetGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeEgressOnlyInternetGatewaysResponse]
 */
public fun Ec2Client.describeEgressOnlyInternetGatewaysPaginated(initialRequest: DescribeEgressOnlyInternetGatewaysRequest): Flow<DescribeEgressOnlyInternetGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeEgressOnlyInternetGatewaysPaginated.describeEgressOnlyInternetGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeEgressOnlyInternetGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeEgressOnlyInternetGatewaysResponse]
 */
public fun Ec2Client.describeEgressOnlyInternetGatewaysPaginated(block: DescribeEgressOnlyInternetGatewaysRequest.Builder.() -> Unit): Flow<DescribeEgressOnlyInternetGatewaysResponse> =
    describeEgressOnlyInternetGatewaysPaginated(DescribeEgressOnlyInternetGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeEgressOnlyInternetGatewaysPaginated]
 * to access the nested member [EgressOnlyInternetGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [EgressOnlyInternetGateway]
 */
@JvmName("describeEgressOnlyInternetGatewaysResponseEgressOnlyInternetGateway")
public fun Flow<DescribeEgressOnlyInternetGatewaysResponse>.egressOnlyInternetGateways(): Flow<EgressOnlyInternetGateway> =
    transform() { response ->
        response.egressOnlyInternetGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeExportImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeExportImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeExportImageTasksResponse]
 */
public fun Ec2Client.describeExportImageTasksPaginated(initialRequest: DescribeExportImageTasksRequest): Flow<DescribeExportImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeExportImageTasksPaginated.describeExportImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeExportImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeExportImageTasksResponse]
 */
public fun Ec2Client.describeExportImageTasksPaginated(block: DescribeExportImageTasksRequest.Builder.() -> Unit): Flow<DescribeExportImageTasksResponse> =
    describeExportImageTasksPaginated(DescribeExportImageTasksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeExportImageTasksPaginated]
 * to access the nested member [ExportImageTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ExportImageTask]
 */
@JvmName("describeExportImageTasksResponseExportImageTask")
public fun Flow<DescribeExportImageTasksResponse>.exportImageTasks(): Flow<ExportImageTask> =
    transform() { response ->
        response.exportImageTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFastLaunchImagesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeFastLaunchImagesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastLaunchImagesResponse]
 */
public fun Ec2Client.describeFastLaunchImagesPaginated(initialRequest: DescribeFastLaunchImagesRequest): Flow<DescribeFastLaunchImagesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFastLaunchImagesPaginated.describeFastLaunchImages(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeFastLaunchImagesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastLaunchImagesResponse]
 */
public fun Ec2Client.describeFastLaunchImagesPaginated(block: DescribeFastLaunchImagesRequest.Builder.() -> Unit): Flow<DescribeFastLaunchImagesResponse> =
    describeFastLaunchImagesPaginated(DescribeFastLaunchImagesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeFastLaunchImagesPaginated]
 * to access the nested member [DescribeFastLaunchImagesSuccessItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastLaunchImagesSuccessItem]
 */
@JvmName("describeFastLaunchImagesResponseDescribeFastLaunchImagesSuccessItem")
public fun Flow<DescribeFastLaunchImagesResponse>.fastLaunchImages(): Flow<DescribeFastLaunchImagesSuccessItem> =
    transform() { response ->
        response.fastLaunchImages?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFastSnapshotRestoresResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeFastSnapshotRestoresRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastSnapshotRestoresResponse]
 */
public fun Ec2Client.describeFastSnapshotRestoresPaginated(initialRequest: DescribeFastSnapshotRestoresRequest): Flow<DescribeFastSnapshotRestoresResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFastSnapshotRestoresPaginated.describeFastSnapshotRestores(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeFastSnapshotRestoresResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastSnapshotRestoresResponse]
 */
public fun Ec2Client.describeFastSnapshotRestoresPaginated(block: DescribeFastSnapshotRestoresRequest.Builder.() -> Unit): Flow<DescribeFastSnapshotRestoresResponse> =
    describeFastSnapshotRestoresPaginated(DescribeFastSnapshotRestoresRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeFastSnapshotRestoresPaginated]
 * to access the nested member [DescribeFastSnapshotRestoreSuccessItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFastSnapshotRestoreSuccessItem]
 */
@JvmName("describeFastSnapshotRestoresResponseDescribeFastSnapshotRestoreSuccessItem")
public fun Flow<DescribeFastSnapshotRestoresResponse>.fastSnapshotRestores(): Flow<DescribeFastSnapshotRestoreSuccessItem> =
    transform() { response ->
        response.fastSnapshotRestores?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFleetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeFleetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFleetsResponse]
 */
public fun Ec2Client.describeFleetsPaginated(initialRequest: DescribeFleetsRequest): Flow<DescribeFleetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFleetsPaginated.describeFleets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeFleetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFleetsResponse]
 */
public fun Ec2Client.describeFleetsPaginated(block: DescribeFleetsRequest.Builder.() -> Unit): Flow<DescribeFleetsResponse> =
    describeFleetsPaginated(DescribeFleetsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeFleetsPaginated]
 * to access the nested member [FleetData]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FleetData]
 */
@JvmName("describeFleetsResponseFleetData")
public fun Flow<DescribeFleetsResponse>.fleets(): Flow<FleetData> =
    transform() { response ->
        response.fleets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFlowLogsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeFlowLogsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFlowLogsResponse]
 */
public fun Ec2Client.describeFlowLogsPaginated(initialRequest: DescribeFlowLogsRequest): Flow<DescribeFlowLogsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFlowLogsPaginated.describeFlowLogs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeFlowLogsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFlowLogsResponse]
 */
public fun Ec2Client.describeFlowLogsPaginated(block: DescribeFlowLogsRequest.Builder.() -> Unit): Flow<DescribeFlowLogsResponse> =
    describeFlowLogsPaginated(DescribeFlowLogsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeFlowLogsPaginated]
 * to access the nested member [FlowLog]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FlowLog]
 */
@JvmName("describeFlowLogsResponseFlowLog")
public fun Flow<DescribeFlowLogsResponse>.flowLogs(): Flow<FlowLog> =
    transform() { response ->
        response.flowLogs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeFpgaImagesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeFpgaImagesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFpgaImagesResponse]
 */
public fun Ec2Client.describeFpgaImagesPaginated(initialRequest: DescribeFpgaImagesRequest): Flow<DescribeFpgaImagesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeFpgaImagesPaginated.describeFpgaImages(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeFpgaImagesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeFpgaImagesResponse]
 */
public fun Ec2Client.describeFpgaImagesPaginated(block: DescribeFpgaImagesRequest.Builder.() -> Unit): Flow<DescribeFpgaImagesResponse> =
    describeFpgaImagesPaginated(DescribeFpgaImagesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeFpgaImagesPaginated]
 * to access the nested member [FpgaImage]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [FpgaImage]
 */
@JvmName("describeFpgaImagesResponseFpgaImage")
public fun Flow<DescribeFpgaImagesResponse>.fpgaImages(): Flow<FpgaImage> =
    transform() { response ->
        response.fpgaImages?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostReservationOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeHostReservationOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationOfferingsResponse]
 */
public fun Ec2Client.describeHostReservationOfferingsPaginated(initialRequest: DescribeHostReservationOfferingsRequest): Flow<DescribeHostReservationOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostReservationOfferingsPaginated.describeHostReservationOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeHostReservationOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationOfferingsResponse]
 */
public fun Ec2Client.describeHostReservationOfferingsPaginated(block: DescribeHostReservationOfferingsRequest.Builder.() -> Unit): Flow<DescribeHostReservationOfferingsResponse> =
    describeHostReservationOfferingsPaginated(DescribeHostReservationOfferingsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeHostReservationOfferingsPaginated]
 * to access the nested member [HostOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [HostOffering]
 */
@JvmName("describeHostReservationOfferingsResponseHostOffering")
public fun Flow<DescribeHostReservationOfferingsResponse>.offeringSet(): Flow<HostOffering> =
    transform() { response ->
        response.offeringSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostReservationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeHostReservationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationsResponse]
 */
public fun Ec2Client.describeHostReservationsPaginated(initialRequest: DescribeHostReservationsRequest): Flow<DescribeHostReservationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostReservationsPaginated.describeHostReservations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeHostReservationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostReservationsResponse]
 */
public fun Ec2Client.describeHostReservationsPaginated(block: DescribeHostReservationsRequest.Builder.() -> Unit): Flow<DescribeHostReservationsResponse> =
    describeHostReservationsPaginated(DescribeHostReservationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeHostReservationsPaginated]
 * to access the nested member [HostReservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [HostReservation]
 */
@JvmName("describeHostReservationsResponseHostReservation")
public fun Flow<DescribeHostReservationsResponse>.hostReservationSet(): Flow<HostReservation> =
    transform() { response ->
        response.hostReservationSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeHostsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeHostsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostsResponse]
 */
public fun Ec2Client.describeHostsPaginated(initialRequest: DescribeHostsRequest): Flow<DescribeHostsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeHostsPaginated.describeHosts(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeHostsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeHostsResponse]
 */
public fun Ec2Client.describeHostsPaginated(block: DescribeHostsRequest.Builder.() -> Unit): Flow<DescribeHostsResponse> =
    describeHostsPaginated(DescribeHostsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeHostsPaginated]
 * to access the nested member [Host]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Host]
 */
@JvmName("describeHostsResponseHost")
public fun Flow<DescribeHostsResponse>.hosts(): Flow<Host> =
    transform() { response ->
        response.hosts?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIamInstanceProfileAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeIamInstanceProfileAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIamInstanceProfileAssociationsResponse]
 */
public fun Ec2Client.describeIamInstanceProfileAssociationsPaginated(initialRequest: DescribeIamInstanceProfileAssociationsRequest): Flow<DescribeIamInstanceProfileAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIamInstanceProfileAssociationsPaginated.describeIamInstanceProfileAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeIamInstanceProfileAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIamInstanceProfileAssociationsResponse]
 */
public fun Ec2Client.describeIamInstanceProfileAssociationsPaginated(block: DescribeIamInstanceProfileAssociationsRequest.Builder.() -> Unit): Flow<DescribeIamInstanceProfileAssociationsResponse> =
    describeIamInstanceProfileAssociationsPaginated(DescribeIamInstanceProfileAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeIamInstanceProfileAssociationsPaginated]
 * to access the nested member [IamInstanceProfileAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IamInstanceProfileAssociation]
 */
@JvmName("describeIamInstanceProfileAssociationsResponseIamInstanceProfileAssociation")
public fun Flow<DescribeIamInstanceProfileAssociationsResponse>.iamInstanceProfileAssociations(): Flow<IamInstanceProfileAssociation> =
    transform() { response ->
        response.iamInstanceProfileAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeImportImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeImportImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportImageTasksResponse]
 */
public fun Ec2Client.describeImportImageTasksPaginated(initialRequest: DescribeImportImageTasksRequest): Flow<DescribeImportImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeImportImageTasksPaginated.describeImportImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeImportImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportImageTasksResponse]
 */
public fun Ec2Client.describeImportImageTasksPaginated(block: DescribeImportImageTasksRequest.Builder.() -> Unit): Flow<DescribeImportImageTasksResponse> =
    describeImportImageTasksPaginated(DescribeImportImageTasksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeImportImageTasksPaginated]
 * to access the nested member [ImportImageTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ImportImageTask]
 */
@JvmName("describeImportImageTasksResponseImportImageTask")
public fun Flow<DescribeImportImageTasksResponse>.importImageTasks(): Flow<ImportImageTask> =
    transform() { response ->
        response.importImageTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeImportSnapshotTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeImportSnapshotTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportSnapshotTasksResponse]
 */
public fun Ec2Client.describeImportSnapshotTasksPaginated(initialRequest: DescribeImportSnapshotTasksRequest): Flow<DescribeImportSnapshotTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeImportSnapshotTasksPaginated.describeImportSnapshotTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeImportSnapshotTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeImportSnapshotTasksResponse]
 */
public fun Ec2Client.describeImportSnapshotTasksPaginated(block: DescribeImportSnapshotTasksRequest.Builder.() -> Unit): Flow<DescribeImportSnapshotTasksResponse> =
    describeImportSnapshotTasksPaginated(DescribeImportSnapshotTasksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeImportSnapshotTasksPaginated]
 * to access the nested member [ImportSnapshotTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ImportSnapshotTask]
 */
@JvmName("describeImportSnapshotTasksResponseImportSnapshotTask")
public fun Flow<DescribeImportSnapshotTasksResponse>.importSnapshotTasks(): Flow<ImportSnapshotTask> =
    transform() { response ->
        response.importSnapshotTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceCreditSpecificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstanceCreditSpecificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceCreditSpecificationsResponse]
 */
public fun Ec2Client.describeInstanceCreditSpecificationsPaginated(initialRequest: DescribeInstanceCreditSpecificationsRequest): Flow<DescribeInstanceCreditSpecificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceCreditSpecificationsPaginated.describeInstanceCreditSpecifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstanceCreditSpecificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceCreditSpecificationsResponse]
 */
public fun Ec2Client.describeInstanceCreditSpecificationsPaginated(block: DescribeInstanceCreditSpecificationsRequest.Builder.() -> Unit): Flow<DescribeInstanceCreditSpecificationsResponse> =
    describeInstanceCreditSpecificationsPaginated(DescribeInstanceCreditSpecificationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstanceCreditSpecificationsPaginated]
 * to access the nested member [InstanceCreditSpecification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceCreditSpecification]
 */
@JvmName("describeInstanceCreditSpecificationsResponseInstanceCreditSpecification")
public fun Flow<DescribeInstanceCreditSpecificationsResponse>.instanceCreditSpecifications(): Flow<InstanceCreditSpecification> =
    transform() { response ->
        response.instanceCreditSpecifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceEventWindowsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstanceEventWindowsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceEventWindowsResponse]
 */
public fun Ec2Client.describeInstanceEventWindowsPaginated(initialRequest: DescribeInstanceEventWindowsRequest): Flow<DescribeInstanceEventWindowsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceEventWindowsPaginated.describeInstanceEventWindows(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstanceEventWindowsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceEventWindowsResponse]
 */
public fun Ec2Client.describeInstanceEventWindowsPaginated(block: DescribeInstanceEventWindowsRequest.Builder.() -> Unit): Flow<DescribeInstanceEventWindowsResponse> =
    describeInstanceEventWindowsPaginated(DescribeInstanceEventWindowsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstanceEventWindowsPaginated]
 * to access the nested member [InstanceEventWindow]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceEventWindow]
 */
@JvmName("describeInstanceEventWindowsResponseInstanceEventWindow")
public fun Flow<DescribeInstanceEventWindowsResponse>.instanceEventWindows(): Flow<InstanceEventWindow> =
    transform() { response ->
        response.instanceEventWindows?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstancesResponse]
 */
public fun Ec2Client.describeInstancesPaginated(initialRequest: DescribeInstancesRequest): Flow<DescribeInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstancesPaginated.describeInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstancesResponse]
 */
public fun Ec2Client.describeInstancesPaginated(block: DescribeInstancesRequest.Builder.() -> Unit): Flow<DescribeInstancesResponse> =
    describeInstancesPaginated(DescribeInstancesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstancesPaginated]
 * to access the nested member [Reservation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Reservation]
 */
@JvmName("describeInstancesResponseReservation")
public fun Flow<DescribeInstancesResponse>.reservations(): Flow<Reservation> =
    transform() { response ->
        response.reservations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstanceStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceStatusResponse]
 */
public fun Ec2Client.describeInstanceStatusPaginated(initialRequest: DescribeInstanceStatusRequest): Flow<DescribeInstanceStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceStatusPaginated.describeInstanceStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstanceStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceStatusResponse]
 */
public fun Ec2Client.describeInstanceStatusPaginated(block: DescribeInstanceStatusRequest.Builder.() -> Unit): Flow<DescribeInstanceStatusResponse> =
    describeInstanceStatusPaginated(DescribeInstanceStatusRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstanceStatusPaginated]
 * to access the nested member [InstanceStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceStatus]
 */
@JvmName("describeInstanceStatusResponseInstanceStatus")
public fun Flow<DescribeInstanceStatusResponse>.instanceStatuses(): Flow<InstanceStatus> =
    transform() { response ->
        response.instanceStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceTypeOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstanceTypeOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypeOfferingsResponse]
 */
public fun Ec2Client.describeInstanceTypeOfferingsPaginated(initialRequest: DescribeInstanceTypeOfferingsRequest): Flow<DescribeInstanceTypeOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceTypeOfferingsPaginated.describeInstanceTypeOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstanceTypeOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypeOfferingsResponse]
 */
public fun Ec2Client.describeInstanceTypeOfferingsPaginated(block: DescribeInstanceTypeOfferingsRequest.Builder.() -> Unit): Flow<DescribeInstanceTypeOfferingsResponse> =
    describeInstanceTypeOfferingsPaginated(DescribeInstanceTypeOfferingsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstanceTypeOfferingsPaginated]
 * to access the nested member [InstanceTypeOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeOffering]
 */
@JvmName("describeInstanceTypeOfferingsResponseInstanceTypeOffering")
public fun Flow<DescribeInstanceTypeOfferingsResponse>.instanceTypeOfferings(): Flow<InstanceTypeOffering> =
    transform() { response ->
        response.instanceTypeOfferings?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInstanceTypesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInstanceTypesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypesResponse]
 */
public fun Ec2Client.describeInstanceTypesPaginated(initialRequest: DescribeInstanceTypesRequest): Flow<DescribeInstanceTypesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInstanceTypesPaginated.describeInstanceTypes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInstanceTypesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInstanceTypesResponse]
 */
public fun Ec2Client.describeInstanceTypesPaginated(block: DescribeInstanceTypesRequest.Builder.() -> Unit): Flow<DescribeInstanceTypesResponse> =
    describeInstanceTypesPaginated(DescribeInstanceTypesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInstanceTypesPaginated]
 * to access the nested member [InstanceTypeInfo]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeInfo]
 */
@JvmName("describeInstanceTypesResponseInstanceTypeInfo")
public fun Flow<DescribeInstanceTypesResponse>.instanceTypes(): Flow<InstanceTypeInfo> =
    transform() { response ->
        response.instanceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeInternetGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeInternetGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInternetGatewaysResponse]
 */
public fun Ec2Client.describeInternetGatewaysPaginated(initialRequest: DescribeInternetGatewaysRequest): Flow<DescribeInternetGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeInternetGatewaysPaginated.describeInternetGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeInternetGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeInternetGatewaysResponse]
 */
public fun Ec2Client.describeInternetGatewaysPaginated(block: DescribeInternetGatewaysRequest.Builder.() -> Unit): Flow<DescribeInternetGatewaysResponse> =
    describeInternetGatewaysPaginated(DescribeInternetGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeInternetGatewaysPaginated]
 * to access the nested member [InternetGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InternetGateway]
 */
@JvmName("describeInternetGatewaysResponseInternetGateway")
public fun Flow<DescribeInternetGatewaysResponse>.internetGateways(): Flow<InternetGateway> =
    transform() { response ->
        response.internetGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamPoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeIpamPoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamPoolsResponse]
 */
public fun Ec2Client.describeIpamPoolsPaginated(initialRequest: DescribeIpamPoolsRequest): Flow<DescribeIpamPoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamPoolsPaginated.describeIpamPools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeIpamPoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamPoolsResponse]
 */
public fun Ec2Client.describeIpamPoolsPaginated(block: DescribeIpamPoolsRequest.Builder.() -> Unit): Flow<DescribeIpamPoolsResponse> =
    describeIpamPoolsPaginated(DescribeIpamPoolsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeIpamPoolsPaginated]
 * to access the nested member [IpamPool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPool]
 */
@JvmName("describeIpamPoolsResponseIpamPool")
public fun Flow<DescribeIpamPoolsResponse>.ipamPools(): Flow<IpamPool> =
    transform() { response ->
        response.ipamPools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeIpamsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamsResponse]
 */
public fun Ec2Client.describeIpamsPaginated(initialRequest: DescribeIpamsRequest): Flow<DescribeIpamsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamsPaginated.describeIpams(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeIpamsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamsResponse]
 */
public fun Ec2Client.describeIpamsPaginated(block: DescribeIpamsRequest.Builder.() -> Unit): Flow<DescribeIpamsResponse> =
    describeIpamsPaginated(DescribeIpamsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeIpamsPaginated]
 * to access the nested member [Ipam]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipam]
 */
@JvmName("describeIpamsResponseIpam")
public fun Flow<DescribeIpamsResponse>.ipams(): Flow<Ipam> =
    transform() { response ->
        response.ipams?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpamScopesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeIpamScopesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamScopesResponse]
 */
public fun Ec2Client.describeIpamScopesPaginated(initialRequest: DescribeIpamScopesRequest): Flow<DescribeIpamScopesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpamScopesPaginated.describeIpamScopes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeIpamScopesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpamScopesResponse]
 */
public fun Ec2Client.describeIpamScopesPaginated(block: DescribeIpamScopesRequest.Builder.() -> Unit): Flow<DescribeIpamScopesResponse> =
    describeIpamScopesPaginated(DescribeIpamScopesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeIpamScopesPaginated]
 * to access the nested member [IpamScope]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamScope]
 */
@JvmName("describeIpamScopesResponseIpamScope")
public fun Flow<DescribeIpamScopesResponse>.ipamScopes(): Flow<IpamScope> =
    transform() { response ->
        response.ipamScopes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeIpv6PoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeIpv6PoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpv6PoolsResponse]
 */
public fun Ec2Client.describeIpv6PoolsPaginated(initialRequest: DescribeIpv6PoolsRequest): Flow<DescribeIpv6PoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeIpv6PoolsPaginated.describeIpv6Pools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeIpv6PoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeIpv6PoolsResponse]
 */
public fun Ec2Client.describeIpv6PoolsPaginated(block: DescribeIpv6PoolsRequest.Builder.() -> Unit): Flow<DescribeIpv6PoolsResponse> =
    describeIpv6PoolsPaginated(DescribeIpv6PoolsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeIpv6PoolsPaginated]
 * to access the nested member [Ipv6Pool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipv6Pool]
 */
@JvmName("describeIpv6PoolsResponseIpv6Pool")
public fun Flow<DescribeIpv6PoolsResponse>.ipv6Pools(): Flow<Ipv6Pool> =
    transform() { response ->
        response.ipv6Pools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplatesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLaunchTemplatesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplatesResponse]
 */
public fun Ec2Client.describeLaunchTemplatesPaginated(initialRequest: DescribeLaunchTemplatesRequest): Flow<DescribeLaunchTemplatesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLaunchTemplatesPaginated.describeLaunchTemplates(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplatesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplatesResponse]
 */
public fun Ec2Client.describeLaunchTemplatesPaginated(block: DescribeLaunchTemplatesRequest.Builder.() -> Unit): Flow<DescribeLaunchTemplatesResponse> =
    describeLaunchTemplatesPaginated(DescribeLaunchTemplatesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLaunchTemplatesPaginated]
 * to access the nested member [LaunchTemplate]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LaunchTemplate]
 */
@JvmName("describeLaunchTemplatesResponseLaunchTemplate")
public fun Flow<DescribeLaunchTemplatesResponse>.launchTemplates(): Flow<LaunchTemplate> =
    transform() { response ->
        response.launchTemplates?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplateVersionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLaunchTemplateVersionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplateVersionsResponse]
 */
public fun Ec2Client.describeLaunchTemplateVersionsPaginated(initialRequest: DescribeLaunchTemplateVersionsRequest): Flow<DescribeLaunchTemplateVersionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLaunchTemplateVersionsPaginated.describeLaunchTemplateVersions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLaunchTemplateVersionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLaunchTemplateVersionsResponse]
 */
public fun Ec2Client.describeLaunchTemplateVersionsPaginated(block: DescribeLaunchTemplateVersionsRequest.Builder.() -> Unit): Flow<DescribeLaunchTemplateVersionsResponse> =
    describeLaunchTemplateVersionsPaginated(DescribeLaunchTemplateVersionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLaunchTemplateVersionsPaginated]
 * to access the nested member [LaunchTemplateVersion]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LaunchTemplateVersion]
 */
@JvmName("describeLaunchTemplateVersionsResponseLaunchTemplateVersion")
public fun Flow<DescribeLaunchTemplateVersionsResponse>.launchTemplateVersions(): Flow<LaunchTemplateVersion> =
    transform() { response ->
        response.launchTemplateVersions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTablesResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTablesPaginated(initialRequest: DescribeLocalGatewayRouteTablesRequest): Flow<DescribeLocalGatewayRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTablesPaginated.describeLocalGatewayRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTablesResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTablesPaginated(block: DescribeLocalGatewayRouteTablesRequest.Builder.() -> Unit): Flow<DescribeLocalGatewayRouteTablesResponse> =
    describeLocalGatewayRouteTablesPaginated(DescribeLocalGatewayRouteTablesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTablesPaginated]
 * to access the nested member [LocalGatewayRouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTable]
 */
@JvmName("describeLocalGatewayRouteTablesResponseLocalGatewayRouteTable")
public fun Flow<DescribeLocalGatewayRouteTablesResponse>.localGatewayRouteTables(): Flow<LocalGatewayRouteTable> =
    transform() { response ->
        response.localGatewayRouteTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated(initialRequest: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest): Flow<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated(block: DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest.Builder.() -> Unit): Flow<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse> =
    describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated(DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsPaginated]
 * to access the nested member [LocalGatewayRouteTableVirtualInterfaceGroupAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTableVirtualInterfaceGroupAssociation]
 */
@JvmName("describeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponseLocalGatewayRouteTableVirtualInterfaceGroupAssociation")
public fun Flow<DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResponse>.localGatewayRouteTableVirtualInterfaceGroupAssociations(): Flow<LocalGatewayRouteTableVirtualInterfaceGroupAssociation> =
    transform() { response ->
        response.localGatewayRouteTableVirtualInterfaceGroupAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVpcAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewayRouteTableVpcAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVpcAssociationsResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTableVpcAssociationsPaginated(initialRequest: DescribeLocalGatewayRouteTableVpcAssociationsRequest): Flow<DescribeLocalGatewayRouteTableVpcAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayRouteTableVpcAssociationsPaginated.describeLocalGatewayRouteTableVpcAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayRouteTableVpcAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayRouteTableVpcAssociationsResponse]
 */
public fun Ec2Client.describeLocalGatewayRouteTableVpcAssociationsPaginated(block: DescribeLocalGatewayRouteTableVpcAssociationsRequest.Builder.() -> Unit): Flow<DescribeLocalGatewayRouteTableVpcAssociationsResponse> =
    describeLocalGatewayRouteTableVpcAssociationsPaginated(DescribeLocalGatewayRouteTableVpcAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewayRouteTableVpcAssociationsPaginated]
 * to access the nested member [LocalGatewayRouteTableVpcAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRouteTableVpcAssociation]
 */
@JvmName("describeLocalGatewayRouteTableVpcAssociationsResponseLocalGatewayRouteTableVpcAssociation")
public fun Flow<DescribeLocalGatewayRouteTableVpcAssociationsResponse>.localGatewayRouteTableVpcAssociations(): Flow<LocalGatewayRouteTableVpcAssociation> =
    transform() { response ->
        response.localGatewayRouteTableVpcAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewaysResponse]
 */
public fun Ec2Client.describeLocalGatewaysPaginated(initialRequest: DescribeLocalGatewaysRequest): Flow<DescribeLocalGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewaysPaginated.describeLocalGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewaysResponse]
 */
public fun Ec2Client.describeLocalGatewaysPaginated(block: DescribeLocalGatewaysRequest.Builder.() -> Unit): Flow<DescribeLocalGatewaysResponse> =
    describeLocalGatewaysPaginated(DescribeLocalGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewaysPaginated]
 * to access the nested member [LocalGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGateway]
 */
@JvmName("describeLocalGatewaysResponseLocalGateway")
public fun Flow<DescribeLocalGatewaysResponse>.localGateways(): Flow<LocalGateway> =
    transform() { response ->
        response.localGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfaceGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewayVirtualInterfaceGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfaceGroupsResponse]
 */
public fun Ec2Client.describeLocalGatewayVirtualInterfaceGroupsPaginated(initialRequest: DescribeLocalGatewayVirtualInterfaceGroupsRequest): Flow<DescribeLocalGatewayVirtualInterfaceGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayVirtualInterfaceGroupsPaginated.describeLocalGatewayVirtualInterfaceGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfaceGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfaceGroupsResponse]
 */
public fun Ec2Client.describeLocalGatewayVirtualInterfaceGroupsPaginated(block: DescribeLocalGatewayVirtualInterfaceGroupsRequest.Builder.() -> Unit): Flow<DescribeLocalGatewayVirtualInterfaceGroupsResponse> =
    describeLocalGatewayVirtualInterfaceGroupsPaginated(DescribeLocalGatewayVirtualInterfaceGroupsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewayVirtualInterfaceGroupsPaginated]
 * to access the nested member [LocalGatewayVirtualInterfaceGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayVirtualInterfaceGroup]
 */
@JvmName("describeLocalGatewayVirtualInterfaceGroupsResponseLocalGatewayVirtualInterfaceGroup")
public fun Flow<DescribeLocalGatewayVirtualInterfaceGroupsResponse>.localGatewayVirtualInterfaceGroups(): Flow<LocalGatewayVirtualInterfaceGroup> =
    transform() { response ->
        response.localGatewayVirtualInterfaceGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfacesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeLocalGatewayVirtualInterfacesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfacesResponse]
 */
public fun Ec2Client.describeLocalGatewayVirtualInterfacesPaginated(initialRequest: DescribeLocalGatewayVirtualInterfacesRequest): Flow<DescribeLocalGatewayVirtualInterfacesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeLocalGatewayVirtualInterfacesPaginated.describeLocalGatewayVirtualInterfaces(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeLocalGatewayVirtualInterfacesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeLocalGatewayVirtualInterfacesResponse]
 */
public fun Ec2Client.describeLocalGatewayVirtualInterfacesPaginated(block: DescribeLocalGatewayVirtualInterfacesRequest.Builder.() -> Unit): Flow<DescribeLocalGatewayVirtualInterfacesResponse> =
    describeLocalGatewayVirtualInterfacesPaginated(DescribeLocalGatewayVirtualInterfacesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeLocalGatewayVirtualInterfacesPaginated]
 * to access the nested member [LocalGatewayVirtualInterface]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayVirtualInterface]
 */
@JvmName("describeLocalGatewayVirtualInterfacesResponseLocalGatewayVirtualInterface")
public fun Flow<DescribeLocalGatewayVirtualInterfacesResponse>.localGatewayVirtualInterfaces(): Flow<LocalGatewayVirtualInterface> =
    transform() { response ->
        response.localGatewayVirtualInterfaces?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeManagedPrefixListsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeManagedPrefixListsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeManagedPrefixListsResponse]
 */
public fun Ec2Client.describeManagedPrefixListsPaginated(initialRequest: DescribeManagedPrefixListsRequest): Flow<DescribeManagedPrefixListsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeManagedPrefixListsPaginated.describeManagedPrefixLists(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeManagedPrefixListsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeManagedPrefixListsResponse]
 */
public fun Ec2Client.describeManagedPrefixListsPaginated(block: DescribeManagedPrefixListsRequest.Builder.() -> Unit): Flow<DescribeManagedPrefixListsResponse> =
    describeManagedPrefixListsPaginated(DescribeManagedPrefixListsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeManagedPrefixListsPaginated]
 * to access the nested member [ManagedPrefixList]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ManagedPrefixList]
 */
@JvmName("describeManagedPrefixListsResponseManagedPrefixList")
public fun Flow<DescribeManagedPrefixListsResponse>.prefixLists(): Flow<ManagedPrefixList> =
    transform() { response ->
        response.prefixLists?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeMovingAddressesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeMovingAddressesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeMovingAddressesResponse]
 */
public fun Ec2Client.describeMovingAddressesPaginated(initialRequest: DescribeMovingAddressesRequest): Flow<DescribeMovingAddressesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeMovingAddressesPaginated.describeMovingAddresses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeMovingAddressesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeMovingAddressesResponse]
 */
public fun Ec2Client.describeMovingAddressesPaginated(block: DescribeMovingAddressesRequest.Builder.() -> Unit): Flow<DescribeMovingAddressesResponse> =
    describeMovingAddressesPaginated(DescribeMovingAddressesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeMovingAddressesPaginated]
 * to access the nested member [MovingAddressStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [MovingAddressStatus]
 */
@JvmName("describeMovingAddressesResponseMovingAddressStatus")
public fun Flow<DescribeMovingAddressesResponse>.movingAddressStatuses(): Flow<MovingAddressStatus> =
    transform() { response ->
        response.movingAddressStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNatGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNatGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNatGatewaysResponse]
 */
public fun Ec2Client.describeNatGatewaysPaginated(initialRequest: DescribeNatGatewaysRequest): Flow<DescribeNatGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNatGatewaysPaginated.describeNatGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNatGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNatGatewaysResponse]
 */
public fun Ec2Client.describeNatGatewaysPaginated(block: DescribeNatGatewaysRequest.Builder.() -> Unit): Flow<DescribeNatGatewaysResponse> =
    describeNatGatewaysPaginated(DescribeNatGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNatGatewaysPaginated]
 * to access the nested member [NatGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NatGateway]
 */
@JvmName("describeNatGatewaysResponseNatGateway")
public fun Flow<DescribeNatGatewaysResponse>.natGateways(): Flow<NatGateway> =
    transform() { response ->
        response.natGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkAclsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkAclsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkAclsResponse]
 */
public fun Ec2Client.describeNetworkAclsPaginated(initialRequest: DescribeNetworkAclsRequest): Flow<DescribeNetworkAclsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkAclsPaginated.describeNetworkAcls(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkAclsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkAclsResponse]
 */
public fun Ec2Client.describeNetworkAclsPaginated(block: DescribeNetworkAclsRequest.Builder.() -> Unit): Flow<DescribeNetworkAclsResponse> =
    describeNetworkAclsPaginated(DescribeNetworkAclsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkAclsPaginated]
 * to access the nested member [NetworkAcl]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkAcl]
 */
@JvmName("describeNetworkAclsResponseNetworkAcl")
public fun Flow<DescribeNetworkAclsResponse>.networkAcls(): Flow<NetworkAcl> =
    transform() { response ->
        response.networkAcls?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopeAnalysesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInsightsAccessScopeAnalysesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopeAnalysesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAccessScopeAnalysesPaginated(initialRequest: DescribeNetworkInsightsAccessScopeAnalysesRequest): Flow<DescribeNetworkInsightsAccessScopeAnalysesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAccessScopeAnalysesPaginated.describeNetworkInsightsAccessScopeAnalyses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopeAnalysesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopeAnalysesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAccessScopeAnalysesPaginated(block: DescribeNetworkInsightsAccessScopeAnalysesRequest.Builder.() -> Unit): Flow<DescribeNetworkInsightsAccessScopeAnalysesResponse> =
    describeNetworkInsightsAccessScopeAnalysesPaginated(DescribeNetworkInsightsAccessScopeAnalysesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAccessScopeAnalysesPaginated]
 * to access the nested member [NetworkInsightsAccessScopeAnalysis]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAccessScopeAnalysis]
 */
@JvmName("describeNetworkInsightsAccessScopeAnalysesResponseNetworkInsightsAccessScopeAnalysis")
public fun Flow<DescribeNetworkInsightsAccessScopeAnalysesResponse>.networkInsightsAccessScopeAnalyses(): Flow<NetworkInsightsAccessScopeAnalysis> =
    transform() { response ->
        response.networkInsightsAccessScopeAnalyses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInsightsAccessScopesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAccessScopesPaginated(initialRequest: DescribeNetworkInsightsAccessScopesRequest): Flow<DescribeNetworkInsightsAccessScopesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAccessScopesPaginated.describeNetworkInsightsAccessScopes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAccessScopesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAccessScopesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAccessScopesPaginated(block: DescribeNetworkInsightsAccessScopesRequest.Builder.() -> Unit): Flow<DescribeNetworkInsightsAccessScopesResponse> =
    describeNetworkInsightsAccessScopesPaginated(DescribeNetworkInsightsAccessScopesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAccessScopesPaginated]
 * to access the nested member [NetworkInsightsAccessScope]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAccessScope]
 */
@JvmName("describeNetworkInsightsAccessScopesResponseNetworkInsightsAccessScope")
public fun Flow<DescribeNetworkInsightsAccessScopesResponse>.networkInsightsAccessScopes(): Flow<NetworkInsightsAccessScope> =
    transform() { response ->
        response.networkInsightsAccessScopes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAnalysesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInsightsAnalysesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAnalysesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAnalysesPaginated(initialRequest: DescribeNetworkInsightsAnalysesRequest): Flow<DescribeNetworkInsightsAnalysesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsAnalysesPaginated.describeNetworkInsightsAnalyses(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsAnalysesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsAnalysesResponse]
 */
public fun Ec2Client.describeNetworkInsightsAnalysesPaginated(block: DescribeNetworkInsightsAnalysesRequest.Builder.() -> Unit): Flow<DescribeNetworkInsightsAnalysesResponse> =
    describeNetworkInsightsAnalysesPaginated(DescribeNetworkInsightsAnalysesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsAnalysesPaginated]
 * to access the nested member [NetworkInsightsAnalysis]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsAnalysis]
 */
@JvmName("describeNetworkInsightsAnalysesResponseNetworkInsightsAnalysis")
public fun Flow<DescribeNetworkInsightsAnalysesResponse>.networkInsightsAnalyses(): Flow<NetworkInsightsAnalysis> =
    transform() { response ->
        response.networkInsightsAnalyses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsPathsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInsightsPathsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsPathsResponse]
 */
public fun Ec2Client.describeNetworkInsightsPathsPaginated(initialRequest: DescribeNetworkInsightsPathsRequest): Flow<DescribeNetworkInsightsPathsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInsightsPathsPaginated.describeNetworkInsightsPaths(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInsightsPathsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInsightsPathsResponse]
 */
public fun Ec2Client.describeNetworkInsightsPathsPaginated(block: DescribeNetworkInsightsPathsRequest.Builder.() -> Unit): Flow<DescribeNetworkInsightsPathsResponse> =
    describeNetworkInsightsPathsPaginated(DescribeNetworkInsightsPathsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInsightsPathsPaginated]
 * to access the nested member [NetworkInsightsPath]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInsightsPath]
 */
@JvmName("describeNetworkInsightsPathsResponseNetworkInsightsPath")
public fun Flow<DescribeNetworkInsightsPathsResponse>.networkInsightsPaths(): Flow<NetworkInsightsPath> =
    transform() { response ->
        response.networkInsightsPaths?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacePermissionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInterfacePermissionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacePermissionsResponse]
 */
public fun Ec2Client.describeNetworkInterfacePermissionsPaginated(initialRequest: DescribeNetworkInterfacePermissionsRequest): Flow<DescribeNetworkInterfacePermissionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInterfacePermissionsPaginated.describeNetworkInterfacePermissions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacePermissionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacePermissionsResponse]
 */
public fun Ec2Client.describeNetworkInterfacePermissionsPaginated(block: DescribeNetworkInterfacePermissionsRequest.Builder.() -> Unit): Flow<DescribeNetworkInterfacePermissionsResponse> =
    describeNetworkInterfacePermissionsPaginated(DescribeNetworkInterfacePermissionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInterfacePermissionsPaginated]
 * to access the nested member [NetworkInterfacePermission]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInterfacePermission]
 */
@JvmName("describeNetworkInterfacePermissionsResponseNetworkInterfacePermission")
public fun Flow<DescribeNetworkInterfacePermissionsResponse>.networkInterfacePermissions(): Flow<NetworkInterfacePermission> =
    transform() { response ->
        response.networkInterfacePermissions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeNetworkInterfacesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacesResponse]
 */
public fun Ec2Client.describeNetworkInterfacesPaginated(initialRequest: DescribeNetworkInterfacesRequest): Flow<DescribeNetworkInterfacesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeNetworkInterfacesPaginated.describeNetworkInterfaces(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeNetworkInterfacesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeNetworkInterfacesResponse]
 */
public fun Ec2Client.describeNetworkInterfacesPaginated(block: DescribeNetworkInterfacesRequest.Builder.() -> Unit): Flow<DescribeNetworkInterfacesResponse> =
    describeNetworkInterfacesPaginated(DescribeNetworkInterfacesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeNetworkInterfacesPaginated]
 * to access the nested member [NetworkInterface]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [NetworkInterface]
 */
@JvmName("describeNetworkInterfacesResponseNetworkInterface")
public fun Flow<DescribeNetworkInterfacesResponse>.networkInterfaces(): Flow<NetworkInterface> =
    transform() { response ->
        response.networkInterfaces?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePrefixListsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribePrefixListsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrefixListsResponse]
 */
public fun Ec2Client.describePrefixListsPaginated(initialRequest: DescribePrefixListsRequest): Flow<DescribePrefixListsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePrefixListsPaginated.describePrefixLists(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribePrefixListsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrefixListsResponse]
 */
public fun Ec2Client.describePrefixListsPaginated(block: DescribePrefixListsRequest.Builder.() -> Unit): Flow<DescribePrefixListsResponse> =
    describePrefixListsPaginated(DescribePrefixListsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describePrefixListsPaginated]
 * to access the nested member [PrefixList]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixList]
 */
@JvmName("describePrefixListsResponsePrefixList")
public fun Flow<DescribePrefixListsResponse>.prefixLists(): Flow<PrefixList> =
    transform() { response ->
        response.prefixLists?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePrincipalIdFormatResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribePrincipalIdFormatRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrincipalIdFormatResponse]
 */
public fun Ec2Client.describePrincipalIdFormatPaginated(initialRequest: DescribePrincipalIdFormatRequest): Flow<DescribePrincipalIdFormatResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePrincipalIdFormatPaginated.describePrincipalIdFormat(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribePrincipalIdFormatResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePrincipalIdFormatResponse]
 */
public fun Ec2Client.describePrincipalIdFormatPaginated(block: DescribePrincipalIdFormatRequest.Builder.() -> Unit): Flow<DescribePrincipalIdFormatResponse> =
    describePrincipalIdFormatPaginated(DescribePrincipalIdFormatRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describePrincipalIdFormatPaginated]
 * to access the nested member [PrincipalIdFormat]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrincipalIdFormat]
 */
@JvmName("describePrincipalIdFormatResponsePrincipalIdFormat")
public fun Flow<DescribePrincipalIdFormatResponse>.principals(): Flow<PrincipalIdFormat> =
    transform() { response ->
        response.principals?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribePublicIpv4PoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribePublicIpv4PoolsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePublicIpv4PoolsResponse]
 */
public fun Ec2Client.describePublicIpv4PoolsPaginated(initialRequest: DescribePublicIpv4PoolsRequest): Flow<DescribePublicIpv4PoolsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describePublicIpv4PoolsPaginated.describePublicIpv4Pools(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribePublicIpv4PoolsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribePublicIpv4PoolsResponse]
 */
public fun Ec2Client.describePublicIpv4PoolsPaginated(block: DescribePublicIpv4PoolsRequest.Builder.() -> Unit): Flow<DescribePublicIpv4PoolsResponse> =
    describePublicIpv4PoolsPaginated(DescribePublicIpv4PoolsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describePublicIpv4PoolsPaginated]
 * to access the nested member [PublicIpv4Pool]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PublicIpv4Pool]
 */
@JvmName("describePublicIpv4PoolsResponsePublicIpv4Pool")
public fun Flow<DescribePublicIpv4PoolsResponse>.publicIpv4Pools(): Flow<PublicIpv4Pool> =
    transform() { response ->
        response.publicIpv4Pools?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReplaceRootVolumeTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeReplaceRootVolumeTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReplaceRootVolumeTasksResponse]
 */
public fun Ec2Client.describeReplaceRootVolumeTasksPaginated(initialRequest: DescribeReplaceRootVolumeTasksRequest): Flow<DescribeReplaceRootVolumeTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReplaceRootVolumeTasksPaginated.describeReplaceRootVolumeTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeReplaceRootVolumeTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReplaceRootVolumeTasksResponse]
 */
public fun Ec2Client.describeReplaceRootVolumeTasksPaginated(block: DescribeReplaceRootVolumeTasksRequest.Builder.() -> Unit): Flow<DescribeReplaceRootVolumeTasksResponse> =
    describeReplaceRootVolumeTasksPaginated(DescribeReplaceRootVolumeTasksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeReplaceRootVolumeTasksPaginated]
 * to access the nested member [ReplaceRootVolumeTask]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReplaceRootVolumeTask]
 */
@JvmName("describeReplaceRootVolumeTasksResponseReplaceRootVolumeTask")
public fun Flow<DescribeReplaceRootVolumeTasksResponse>.replaceRootVolumeTasks(): Flow<ReplaceRootVolumeTask> =
    transform() { response ->
        response.replaceRootVolumeTasks?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesModificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeReservedInstancesModificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesModificationsResponse]
 */
public fun Ec2Client.describeReservedInstancesModificationsPaginated(initialRequest: DescribeReservedInstancesModificationsRequest): Flow<DescribeReservedInstancesModificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReservedInstancesModificationsPaginated.describeReservedInstancesModifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesModificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesModificationsResponse]
 */
public fun Ec2Client.describeReservedInstancesModificationsPaginated(block: DescribeReservedInstancesModificationsRequest.Builder.() -> Unit): Flow<DescribeReservedInstancesModificationsResponse> =
    describeReservedInstancesModificationsPaginated(DescribeReservedInstancesModificationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeReservedInstancesModificationsPaginated]
 * to access the nested member [ReservedInstancesModification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReservedInstancesModification]
 */
@JvmName("describeReservedInstancesModificationsResponseReservedInstancesModification")
public fun Flow<DescribeReservedInstancesModificationsResponse>.reservedInstancesModifications(): Flow<ReservedInstancesModification> =
    transform() { response ->
        response.reservedInstancesModifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeReservedInstancesOfferingsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesOfferingsResponse]
 */
public fun Ec2Client.describeReservedInstancesOfferingsPaginated(initialRequest: DescribeReservedInstancesOfferingsRequest): Flow<DescribeReservedInstancesOfferingsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeReservedInstancesOfferingsPaginated.describeReservedInstancesOfferings(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeReservedInstancesOfferingsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeReservedInstancesOfferingsResponse]
 */
public fun Ec2Client.describeReservedInstancesOfferingsPaginated(block: DescribeReservedInstancesOfferingsRequest.Builder.() -> Unit): Flow<DescribeReservedInstancesOfferingsResponse> =
    describeReservedInstancesOfferingsPaginated(DescribeReservedInstancesOfferingsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeReservedInstancesOfferingsPaginated]
 * to access the nested member [ReservedInstancesOffering]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ReservedInstancesOffering]
 */
@JvmName("describeReservedInstancesOfferingsResponseReservedInstancesOffering")
public fun Flow<DescribeReservedInstancesOfferingsResponse>.reservedInstancesOfferings(): Flow<ReservedInstancesOffering> =
    transform() { response ->
        response.reservedInstancesOfferings?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeRouteTablesResponse]
 */
public fun Ec2Client.describeRouteTablesPaginated(initialRequest: DescribeRouteTablesRequest): Flow<DescribeRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeRouteTablesPaginated.describeRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeRouteTablesResponse]
 */
public fun Ec2Client.describeRouteTablesPaginated(block: DescribeRouteTablesRequest.Builder.() -> Unit): Flow<DescribeRouteTablesResponse> =
    describeRouteTablesPaginated(DescribeRouteTablesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeRouteTablesPaginated]
 * to access the nested member [RouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [RouteTable]
 */
@JvmName("describeRouteTablesResponseRouteTable")
public fun Flow<DescribeRouteTablesResponse>.routeTables(): Flow<RouteTable> =
    transform() { response ->
        response.routeTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeScheduledInstanceAvailabilityResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeScheduledInstanceAvailabilityRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstanceAvailabilityResponse]
 */
public fun Ec2Client.describeScheduledInstanceAvailabilityPaginated(initialRequest: DescribeScheduledInstanceAvailabilityRequest): Flow<DescribeScheduledInstanceAvailabilityResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeScheduledInstanceAvailabilityPaginated.describeScheduledInstanceAvailability(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeScheduledInstanceAvailabilityResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstanceAvailabilityResponse]
 */
public fun Ec2Client.describeScheduledInstanceAvailabilityPaginated(block: DescribeScheduledInstanceAvailabilityRequest.Builder.() -> Unit): Flow<DescribeScheduledInstanceAvailabilityResponse> =
    describeScheduledInstanceAvailabilityPaginated(DescribeScheduledInstanceAvailabilityRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeScheduledInstanceAvailabilityPaginated]
 * to access the nested member [ScheduledInstanceAvailability]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ScheduledInstanceAvailability]
 */
@JvmName("describeScheduledInstanceAvailabilityResponseScheduledInstanceAvailability")
public fun Flow<DescribeScheduledInstanceAvailabilityResponse>.scheduledInstanceAvailabilitySet(): Flow<ScheduledInstanceAvailability> =
    transform() { response ->
        response.scheduledInstanceAvailabilitySet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeScheduledInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeScheduledInstancesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstancesResponse]
 */
public fun Ec2Client.describeScheduledInstancesPaginated(initialRequest: DescribeScheduledInstancesRequest): Flow<DescribeScheduledInstancesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeScheduledInstancesPaginated.describeScheduledInstances(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeScheduledInstancesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeScheduledInstancesResponse]
 */
public fun Ec2Client.describeScheduledInstancesPaginated(block: DescribeScheduledInstancesRequest.Builder.() -> Unit): Flow<DescribeScheduledInstancesResponse> =
    describeScheduledInstancesPaginated(DescribeScheduledInstancesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeScheduledInstancesPaginated]
 * to access the nested member [ScheduledInstance]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ScheduledInstance]
 */
@JvmName("describeScheduledInstancesResponseScheduledInstance")
public fun Flow<DescribeScheduledInstancesResponse>.scheduledInstanceSet(): Flow<ScheduledInstance> =
    transform() { response ->
        response.scheduledInstanceSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupRulesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSecurityGroupRulesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupRulesResponse]
 */
public fun Ec2Client.describeSecurityGroupRulesPaginated(initialRequest: DescribeSecurityGroupRulesRequest): Flow<DescribeSecurityGroupRulesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSecurityGroupRulesPaginated.describeSecurityGroupRules(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupRulesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupRulesResponse]
 */
public fun Ec2Client.describeSecurityGroupRulesPaginated(block: DescribeSecurityGroupRulesRequest.Builder.() -> Unit): Flow<DescribeSecurityGroupRulesResponse> =
    describeSecurityGroupRulesPaginated(DescribeSecurityGroupRulesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSecurityGroupRulesPaginated]
 * to access the nested member [SecurityGroupRule]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SecurityGroupRule]
 */
@JvmName("describeSecurityGroupRulesResponseSecurityGroupRule")
public fun Flow<DescribeSecurityGroupRulesResponse>.securityGroupRules(): Flow<SecurityGroupRule> =
    transform() { response ->
        response.securityGroupRules?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSecurityGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupsResponse]
 */
public fun Ec2Client.describeSecurityGroupsPaginated(initialRequest: DescribeSecurityGroupsRequest): Flow<DescribeSecurityGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSecurityGroupsPaginated.describeSecurityGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSecurityGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSecurityGroupsResponse]
 */
public fun Ec2Client.describeSecurityGroupsPaginated(block: DescribeSecurityGroupsRequest.Builder.() -> Unit): Flow<DescribeSecurityGroupsResponse> =
    describeSecurityGroupsPaginated(DescribeSecurityGroupsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSecurityGroupsPaginated]
 * to access the nested member [SecurityGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SecurityGroup]
 */
@JvmName("describeSecurityGroupsResponseSecurityGroup")
public fun Flow<DescribeSecurityGroupsResponse>.securityGroups(): Flow<SecurityGroup> =
    transform() { response ->
        response.securityGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSnapshotsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSnapshotsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotsResponse]
 */
public fun Ec2Client.describeSnapshotsPaginated(initialRequest: DescribeSnapshotsRequest): Flow<DescribeSnapshotsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSnapshotsPaginated.describeSnapshots(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSnapshotsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotsResponse]
 */
public fun Ec2Client.describeSnapshotsPaginated(block: DescribeSnapshotsRequest.Builder.() -> Unit): Flow<DescribeSnapshotsResponse> =
    describeSnapshotsPaginated(DescribeSnapshotsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSnapshotsPaginated]
 * to access the nested member [Snapshot]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Snapshot]
 */
@JvmName("describeSnapshotsResponseSnapshot")
public fun Flow<DescribeSnapshotsResponse>.snapshots(): Flow<Snapshot> =
    transform() { response ->
        response.snapshots?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSnapshotTierStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSnapshotTierStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotTierStatusResponse]
 */
public fun Ec2Client.describeSnapshotTierStatusPaginated(initialRequest: DescribeSnapshotTierStatusRequest): Flow<DescribeSnapshotTierStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSnapshotTierStatusPaginated.describeSnapshotTierStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSnapshotTierStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSnapshotTierStatusResponse]
 */
public fun Ec2Client.describeSnapshotTierStatusPaginated(block: DescribeSnapshotTierStatusRequest.Builder.() -> Unit): Flow<DescribeSnapshotTierStatusResponse> =
    describeSnapshotTierStatusPaginated(DescribeSnapshotTierStatusRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSnapshotTierStatusPaginated]
 * to access the nested member [SnapshotTierStatus]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SnapshotTierStatus]
 */
@JvmName("describeSnapshotTierStatusResponseSnapshotTierStatus")
public fun Flow<DescribeSnapshotTierStatusResponse>.snapshotTierStatuses(): Flow<SnapshotTierStatus> =
    transform() { response ->
        response.snapshotTierStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotFleetRequestsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSpotFleetRequestsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotFleetRequestsResponse]
 */
public fun Ec2Client.describeSpotFleetRequestsPaginated(initialRequest: DescribeSpotFleetRequestsRequest): Flow<DescribeSpotFleetRequestsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotFleetRequestsPaginated.describeSpotFleetRequests(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSpotFleetRequestsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotFleetRequestsResponse]
 */
public fun Ec2Client.describeSpotFleetRequestsPaginated(block: DescribeSpotFleetRequestsRequest.Builder.() -> Unit): Flow<DescribeSpotFleetRequestsResponse> =
    describeSpotFleetRequestsPaginated(DescribeSpotFleetRequestsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSpotFleetRequestsPaginated]
 * to access the nested member [SpotFleetRequestConfig]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotFleetRequestConfig]
 */
@JvmName("describeSpotFleetRequestsResponseSpotFleetRequestConfig")
public fun Flow<DescribeSpotFleetRequestsResponse>.spotFleetRequestConfigs(): Flow<SpotFleetRequestConfig> =
    transform() { response ->
        response.spotFleetRequestConfigs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotInstanceRequestsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSpotInstanceRequestsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotInstanceRequestsResponse]
 */
public fun Ec2Client.describeSpotInstanceRequestsPaginated(initialRequest: DescribeSpotInstanceRequestsRequest): Flow<DescribeSpotInstanceRequestsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotInstanceRequestsPaginated.describeSpotInstanceRequests(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSpotInstanceRequestsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotInstanceRequestsResponse]
 */
public fun Ec2Client.describeSpotInstanceRequestsPaginated(block: DescribeSpotInstanceRequestsRequest.Builder.() -> Unit): Flow<DescribeSpotInstanceRequestsResponse> =
    describeSpotInstanceRequestsPaginated(DescribeSpotInstanceRequestsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSpotInstanceRequestsPaginated]
 * to access the nested member [SpotInstanceRequest]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotInstanceRequest]
 */
@JvmName("describeSpotInstanceRequestsResponseSpotInstanceRequest")
public fun Flow<DescribeSpotInstanceRequestsResponse>.spotInstanceRequests(): Flow<SpotInstanceRequest> =
    transform() { response ->
        response.spotInstanceRequests?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSpotPriceHistoryResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSpotPriceHistoryRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotPriceHistoryResponse]
 */
public fun Ec2Client.describeSpotPriceHistoryPaginated(initialRequest: DescribeSpotPriceHistoryRequest): Flow<DescribeSpotPriceHistoryResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSpotPriceHistoryPaginated.describeSpotPriceHistory(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSpotPriceHistoryResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSpotPriceHistoryResponse]
 */
public fun Ec2Client.describeSpotPriceHistoryPaginated(block: DescribeSpotPriceHistoryRequest.Builder.() -> Unit): Flow<DescribeSpotPriceHistoryResponse> =
    describeSpotPriceHistoryPaginated(DescribeSpotPriceHistoryRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSpotPriceHistoryPaginated]
 * to access the nested member [SpotPrice]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotPrice]
 */
@JvmName("describeSpotPriceHistoryResponseSpotPrice")
public fun Flow<DescribeSpotPriceHistoryResponse>.spotPriceHistory(): Flow<SpotPrice> =
    transform() { response ->
        response.spotPriceHistory?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeStaleSecurityGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeStaleSecurityGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStaleSecurityGroupsResponse]
 */
public fun Ec2Client.describeStaleSecurityGroupsPaginated(initialRequest: DescribeStaleSecurityGroupsRequest): Flow<DescribeStaleSecurityGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeStaleSecurityGroupsPaginated.describeStaleSecurityGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeStaleSecurityGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStaleSecurityGroupsResponse]
 */
public fun Ec2Client.describeStaleSecurityGroupsPaginated(block: DescribeStaleSecurityGroupsRequest.Builder.() -> Unit): Flow<DescribeStaleSecurityGroupsResponse> =
    describeStaleSecurityGroupsPaginated(DescribeStaleSecurityGroupsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeStaleSecurityGroupsPaginated]
 * to access the nested member [StaleSecurityGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [StaleSecurityGroup]
 */
@JvmName("describeStaleSecurityGroupsResponseStaleSecurityGroup")
public fun Flow<DescribeStaleSecurityGroupsResponse>.staleSecurityGroupSet(): Flow<StaleSecurityGroup> =
    transform() { response ->
        response.staleSecurityGroupSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeStoreImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeStoreImageTasksRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStoreImageTasksResponse]
 */
public fun Ec2Client.describeStoreImageTasksPaginated(initialRequest: DescribeStoreImageTasksRequest): Flow<DescribeStoreImageTasksResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeStoreImageTasksPaginated.describeStoreImageTasks(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeStoreImageTasksResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeStoreImageTasksResponse]
 */
public fun Ec2Client.describeStoreImageTasksPaginated(block: DescribeStoreImageTasksRequest.Builder.() -> Unit): Flow<DescribeStoreImageTasksResponse> =
    describeStoreImageTasksPaginated(DescribeStoreImageTasksRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeStoreImageTasksPaginated]
 * to access the nested member [StoreImageTaskResult]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [StoreImageTaskResult]
 */
@JvmName("describeStoreImageTasksResponseStoreImageTaskResult")
public fun Flow<DescribeStoreImageTasksResponse>.storeImageTaskResults(): Flow<StoreImageTaskResult> =
    transform() { response ->
        response.storeImageTaskResults?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeSubnetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeSubnetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSubnetsResponse]
 */
public fun Ec2Client.describeSubnetsPaginated(initialRequest: DescribeSubnetsRequest): Flow<DescribeSubnetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeSubnetsPaginated.describeSubnets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeSubnetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeSubnetsResponse]
 */
public fun Ec2Client.describeSubnetsPaginated(block: DescribeSubnetsRequest.Builder.() -> Unit): Flow<DescribeSubnetsResponse> =
    describeSubnetsPaginated(DescribeSubnetsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeSubnetsPaginated]
 * to access the nested member [Subnet]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Subnet]
 */
@JvmName("describeSubnetsResponseSubnet")
public fun Flow<DescribeSubnetsResponse>.subnets(): Flow<Subnet> =
    transform() { response ->
        response.subnets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTagsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTagsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTagsResponse]
 */
public fun Ec2Client.describeTagsPaginated(initialRequest: DescribeTagsRequest): Flow<DescribeTagsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTagsPaginated.describeTags(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTagsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTagsResponse]
 */
public fun Ec2Client.describeTagsPaginated(block: DescribeTagsRequest.Builder.() -> Unit): Flow<DescribeTagsResponse> =
    describeTagsPaginated(DescribeTagsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTagsPaginated]
 * to access the nested member [TagDescription]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TagDescription]
 */
@JvmName("describeTagsResponseTagDescription")
public fun Flow<DescribeTagsResponse>.tags(): Flow<TagDescription> =
    transform() { response ->
        response.tags?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorFiltersResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTrafficMirrorFiltersRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorFiltersResponse]
 */
public fun Ec2Client.describeTrafficMirrorFiltersPaginated(initialRequest: DescribeTrafficMirrorFiltersRequest): Flow<DescribeTrafficMirrorFiltersResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorFiltersPaginated.describeTrafficMirrorFilters(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorFiltersResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorFiltersResponse]
 */
public fun Ec2Client.describeTrafficMirrorFiltersPaginated(block: DescribeTrafficMirrorFiltersRequest.Builder.() -> Unit): Flow<DescribeTrafficMirrorFiltersResponse> =
    describeTrafficMirrorFiltersPaginated(DescribeTrafficMirrorFiltersRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorFiltersPaginated]
 * to access the nested member [TrafficMirrorFilter]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorFilter]
 */
@JvmName("describeTrafficMirrorFiltersResponseTrafficMirrorFilter")
public fun Flow<DescribeTrafficMirrorFiltersResponse>.trafficMirrorFilters(): Flow<TrafficMirrorFilter> =
    transform() { response ->
        response.trafficMirrorFilters?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorSessionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTrafficMirrorSessionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorSessionsResponse]
 */
public fun Ec2Client.describeTrafficMirrorSessionsPaginated(initialRequest: DescribeTrafficMirrorSessionsRequest): Flow<DescribeTrafficMirrorSessionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorSessionsPaginated.describeTrafficMirrorSessions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorSessionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorSessionsResponse]
 */
public fun Ec2Client.describeTrafficMirrorSessionsPaginated(block: DescribeTrafficMirrorSessionsRequest.Builder.() -> Unit): Flow<DescribeTrafficMirrorSessionsResponse> =
    describeTrafficMirrorSessionsPaginated(DescribeTrafficMirrorSessionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorSessionsPaginated]
 * to access the nested member [TrafficMirrorSession]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorSession]
 */
@JvmName("describeTrafficMirrorSessionsResponseTrafficMirrorSession")
public fun Flow<DescribeTrafficMirrorSessionsResponse>.trafficMirrorSessions(): Flow<TrafficMirrorSession> =
    transform() { response ->
        response.trafficMirrorSessions?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorTargetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTrafficMirrorTargetsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorTargetsResponse]
 */
public fun Ec2Client.describeTrafficMirrorTargetsPaginated(initialRequest: DescribeTrafficMirrorTargetsRequest): Flow<DescribeTrafficMirrorTargetsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrafficMirrorTargetsPaginated.describeTrafficMirrorTargets(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTrafficMirrorTargetsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrafficMirrorTargetsResponse]
 */
public fun Ec2Client.describeTrafficMirrorTargetsPaginated(block: DescribeTrafficMirrorTargetsRequest.Builder.() -> Unit): Flow<DescribeTrafficMirrorTargetsResponse> =
    describeTrafficMirrorTargetsPaginated(DescribeTrafficMirrorTargetsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTrafficMirrorTargetsPaginated]
 * to access the nested member [TrafficMirrorTarget]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrafficMirrorTarget]
 */
@JvmName("describeTrafficMirrorTargetsResponseTrafficMirrorTarget")
public fun Flow<DescribeTrafficMirrorTargetsResponse>.trafficMirrorTargets(): Flow<TrafficMirrorTarget> =
    transform() { response ->
        response.trafficMirrorTargets?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayAttachmentsPaginated(initialRequest: DescribeTransitGatewayAttachmentsRequest): Flow<DescribeTransitGatewayAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayAttachmentsPaginated.describeTransitGatewayAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayAttachmentsPaginated(block: DescribeTransitGatewayAttachmentsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayAttachmentsResponse> =
    describeTransitGatewayAttachmentsPaginated(DescribeTransitGatewayAttachmentsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayAttachmentsPaginated]
 * to access the nested member [TransitGatewayAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayAttachment]
 */
@JvmName("describeTransitGatewayAttachmentsResponseTransitGatewayAttachment")
public fun Flow<DescribeTransitGatewayAttachmentsResponse>.transitGatewayAttachments(): Flow<TransitGatewayAttachment> =
    transform() { response ->
        response.transitGatewayAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectPeersResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayConnectPeersRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectPeersResponse]
 */
public fun Ec2Client.describeTransitGatewayConnectPeersPaginated(initialRequest: DescribeTransitGatewayConnectPeersRequest): Flow<DescribeTransitGatewayConnectPeersResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayConnectPeersPaginated.describeTransitGatewayConnectPeers(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectPeersResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectPeersResponse]
 */
public fun Ec2Client.describeTransitGatewayConnectPeersPaginated(block: DescribeTransitGatewayConnectPeersRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayConnectPeersResponse> =
    describeTransitGatewayConnectPeersPaginated(DescribeTransitGatewayConnectPeersRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayConnectPeersPaginated]
 * to access the nested member [TransitGatewayConnectPeer]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayConnectPeer]
 */
@JvmName("describeTransitGatewayConnectPeersResponseTransitGatewayConnectPeer")
public fun Flow<DescribeTransitGatewayConnectPeersResponse>.transitGatewayConnectPeers(): Flow<TransitGatewayConnectPeer> =
    transform() { response ->
        response.transitGatewayConnectPeers?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayConnectsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectsResponse]
 */
public fun Ec2Client.describeTransitGatewayConnectsPaginated(initialRequest: DescribeTransitGatewayConnectsRequest): Flow<DescribeTransitGatewayConnectsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayConnectsPaginated.describeTransitGatewayConnects(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayConnectsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayConnectsResponse]
 */
public fun Ec2Client.describeTransitGatewayConnectsPaginated(block: DescribeTransitGatewayConnectsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayConnectsResponse> =
    describeTransitGatewayConnectsPaginated(DescribeTransitGatewayConnectsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayConnectsPaginated]
 * to access the nested member [TransitGatewayConnect]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayConnect]
 */
@JvmName("describeTransitGatewayConnectsResponseTransitGatewayConnect")
public fun Flow<DescribeTransitGatewayConnectsResponse>.transitGatewayConnects(): Flow<TransitGatewayConnect> =
    transform() { response ->
        response.transitGatewayConnects?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayMulticastDomainsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayMulticastDomainsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayMulticastDomainsResponse]
 */
public fun Ec2Client.describeTransitGatewayMulticastDomainsPaginated(initialRequest: DescribeTransitGatewayMulticastDomainsRequest): Flow<DescribeTransitGatewayMulticastDomainsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayMulticastDomainsPaginated.describeTransitGatewayMulticastDomains(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayMulticastDomainsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayMulticastDomainsResponse]
 */
public fun Ec2Client.describeTransitGatewayMulticastDomainsPaginated(block: DescribeTransitGatewayMulticastDomainsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayMulticastDomainsResponse> =
    describeTransitGatewayMulticastDomainsPaginated(DescribeTransitGatewayMulticastDomainsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayMulticastDomainsPaginated]
 * to access the nested member [TransitGatewayMulticastDomain]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastDomain]
 */
@JvmName("describeTransitGatewayMulticastDomainsResponseTransitGatewayMulticastDomain")
public fun Flow<DescribeTransitGatewayMulticastDomainsResponse>.transitGatewayMulticastDomains(): Flow<TransitGatewayMulticastDomain> =
    transform() { response ->
        response.transitGatewayMulticastDomains?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayPeeringAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayPeeringAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayPeeringAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayPeeringAttachmentsPaginated(initialRequest: DescribeTransitGatewayPeeringAttachmentsRequest): Flow<DescribeTransitGatewayPeeringAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayPeeringAttachmentsPaginated.describeTransitGatewayPeeringAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayPeeringAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayPeeringAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayPeeringAttachmentsPaginated(block: DescribeTransitGatewayPeeringAttachmentsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayPeeringAttachmentsResponse> =
    describeTransitGatewayPeeringAttachmentsPaginated(DescribeTransitGatewayPeeringAttachmentsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayPeeringAttachmentsPaginated]
 * to access the nested member [TransitGatewayPeeringAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPeeringAttachment]
 */
@JvmName("describeTransitGatewayPeeringAttachmentsResponseTransitGatewayPeeringAttachment")
public fun Flow<DescribeTransitGatewayPeeringAttachmentsResponse>.transitGatewayPeeringAttachments(): Flow<TransitGatewayPeeringAttachment> =
    transform() { response ->
        response.transitGatewayPeeringAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayPolicyTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayPolicyTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayPolicyTablesResponse]
 */
public fun Ec2Client.describeTransitGatewayPolicyTablesPaginated(initialRequest: DescribeTransitGatewayPolicyTablesRequest): Flow<DescribeTransitGatewayPolicyTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayPolicyTablesPaginated.describeTransitGatewayPolicyTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayPolicyTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayPolicyTablesResponse]
 */
public fun Ec2Client.describeTransitGatewayPolicyTablesPaginated(block: DescribeTransitGatewayPolicyTablesRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayPolicyTablesResponse> =
    describeTransitGatewayPolicyTablesPaginated(DescribeTransitGatewayPolicyTablesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayPolicyTablesPaginated]
 * to access the nested member [TransitGatewayPolicyTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPolicyTable]
 */
@JvmName("describeTransitGatewayPolicyTablesResponseTransitGatewayPolicyTable")
public fun Flow<DescribeTransitGatewayPolicyTablesResponse>.transitGatewayPolicyTables(): Flow<TransitGatewayPolicyTable> =
    transform() { response ->
        response.transitGatewayPolicyTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayRouteTableAnnouncementsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayRouteTableAnnouncementsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayRouteTableAnnouncementsResponse]
 */
public fun Ec2Client.describeTransitGatewayRouteTableAnnouncementsPaginated(initialRequest: DescribeTransitGatewayRouteTableAnnouncementsRequest): Flow<DescribeTransitGatewayRouteTableAnnouncementsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayRouteTableAnnouncementsPaginated.describeTransitGatewayRouteTableAnnouncements(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayRouteTableAnnouncementsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayRouteTableAnnouncementsResponse]
 */
public fun Ec2Client.describeTransitGatewayRouteTableAnnouncementsPaginated(block: DescribeTransitGatewayRouteTableAnnouncementsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayRouteTableAnnouncementsResponse> =
    describeTransitGatewayRouteTableAnnouncementsPaginated(DescribeTransitGatewayRouteTableAnnouncementsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayRouteTableAnnouncementsPaginated]
 * to access the nested member [TransitGatewayRouteTableAnnouncement]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTableAnnouncement]
 */
@JvmName("describeTransitGatewayRouteTableAnnouncementsResponseTransitGatewayRouteTableAnnouncement")
public fun Flow<DescribeTransitGatewayRouteTableAnnouncementsResponse>.transitGatewayRouteTableAnnouncements(): Flow<TransitGatewayRouteTableAnnouncement> =
    transform() { response ->
        response.transitGatewayRouteTableAnnouncements?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayRouteTablesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayRouteTablesResponse]
 */
public fun Ec2Client.describeTransitGatewayRouteTablesPaginated(initialRequest: DescribeTransitGatewayRouteTablesRequest): Flow<DescribeTransitGatewayRouteTablesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayRouteTablesPaginated.describeTransitGatewayRouteTables(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayRouteTablesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayRouteTablesResponse]
 */
public fun Ec2Client.describeTransitGatewayRouteTablesPaginated(block: DescribeTransitGatewayRouteTablesRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayRouteTablesResponse> =
    describeTransitGatewayRouteTablesPaginated(DescribeTransitGatewayRouteTablesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayRouteTablesPaginated]
 * to access the nested member [TransitGatewayRouteTable]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTable]
 */
@JvmName("describeTransitGatewayRouteTablesResponseTransitGatewayRouteTable")
public fun Flow<DescribeTransitGatewayRouteTablesResponse>.transitGatewayRouteTables(): Flow<TransitGatewayRouteTable> =
    transform() { response ->
        response.transitGatewayRouteTables?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewaysRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewaysResponse]
 */
public fun Ec2Client.describeTransitGatewaysPaginated(initialRequest: DescribeTransitGatewaysRequest): Flow<DescribeTransitGatewaysResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewaysPaginated.describeTransitGateways(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewaysResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewaysResponse]
 */
public fun Ec2Client.describeTransitGatewaysPaginated(block: DescribeTransitGatewaysRequest.Builder.() -> Unit): Flow<DescribeTransitGatewaysResponse> =
    describeTransitGatewaysPaginated(DescribeTransitGatewaysRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewaysPaginated]
 * to access the nested member [TransitGateway]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGateway]
 */
@JvmName("describeTransitGatewaysResponseTransitGateway")
public fun Flow<DescribeTransitGatewaysResponse>.transitGateways(): Flow<TransitGateway> =
    transform() { response ->
        response.transitGateways?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayVpcAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTransitGatewayVpcAttachmentsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayVpcAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayVpcAttachmentsPaginated(initialRequest: DescribeTransitGatewayVpcAttachmentsRequest): Flow<DescribeTransitGatewayVpcAttachmentsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTransitGatewayVpcAttachmentsPaginated.describeTransitGatewayVpcAttachments(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTransitGatewayVpcAttachmentsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTransitGatewayVpcAttachmentsResponse]
 */
public fun Ec2Client.describeTransitGatewayVpcAttachmentsPaginated(block: DescribeTransitGatewayVpcAttachmentsRequest.Builder.() -> Unit): Flow<DescribeTransitGatewayVpcAttachmentsResponse> =
    describeTransitGatewayVpcAttachmentsPaginated(DescribeTransitGatewayVpcAttachmentsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTransitGatewayVpcAttachmentsPaginated]
 * to access the nested member [TransitGatewayVpcAttachment]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayVpcAttachment]
 */
@JvmName("describeTransitGatewayVpcAttachmentsResponseTransitGatewayVpcAttachment")
public fun Flow<DescribeTransitGatewayVpcAttachmentsResponse>.transitGatewayVpcAttachments(): Flow<TransitGatewayVpcAttachment> =
    transform() { response ->
        response.transitGatewayVpcAttachments?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeTrunkInterfaceAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeTrunkInterfaceAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrunkInterfaceAssociationsResponse]
 */
public fun Ec2Client.describeTrunkInterfaceAssociationsPaginated(initialRequest: DescribeTrunkInterfaceAssociationsRequest): Flow<DescribeTrunkInterfaceAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeTrunkInterfaceAssociationsPaginated.describeTrunkInterfaceAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeTrunkInterfaceAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeTrunkInterfaceAssociationsResponse]
 */
public fun Ec2Client.describeTrunkInterfaceAssociationsPaginated(block: DescribeTrunkInterfaceAssociationsRequest.Builder.() -> Unit): Flow<DescribeTrunkInterfaceAssociationsResponse> =
    describeTrunkInterfaceAssociationsPaginated(DescribeTrunkInterfaceAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeTrunkInterfaceAssociationsPaginated]
 * to access the nested member [TrunkInterfaceAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TrunkInterfaceAssociation]
 */
@JvmName("describeTrunkInterfaceAssociationsResponseTrunkInterfaceAssociation")
public fun Flow<DescribeTrunkInterfaceAssociationsResponse>.interfaceAssociations(): Flow<TrunkInterfaceAssociation> =
    transform() { response ->
        response.interfaceAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVolumesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesResponse]
 */
public fun Ec2Client.describeVolumesPaginated(initialRequest: DescribeVolumesRequest): Flow<DescribeVolumesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumesPaginated.describeVolumes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVolumesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesResponse]
 */
public fun Ec2Client.describeVolumesPaginated(block: DescribeVolumesRequest.Builder.() -> Unit): Flow<DescribeVolumesResponse> =
    describeVolumesPaginated(DescribeVolumesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVolumesPaginated]
 * to access the nested member [Volume]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Volume]
 */
@JvmName("describeVolumesResponseVolume")
public fun Flow<DescribeVolumesResponse>.volumes(): Flow<Volume> =
    transform() { response ->
        response.volumes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumesModificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVolumesModificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesModificationsResponse]
 */
public fun Ec2Client.describeVolumesModificationsPaginated(initialRequest: DescribeVolumesModificationsRequest): Flow<DescribeVolumesModificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumesModificationsPaginated.describeVolumesModifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVolumesModificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumesModificationsResponse]
 */
public fun Ec2Client.describeVolumesModificationsPaginated(block: DescribeVolumesModificationsRequest.Builder.() -> Unit): Flow<DescribeVolumesModificationsResponse> =
    describeVolumesModificationsPaginated(DescribeVolumesModificationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVolumesModificationsPaginated]
 * to access the nested member [VolumeModification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VolumeModification]
 */
@JvmName("describeVolumesModificationsResponseVolumeModification")
public fun Flow<DescribeVolumesModificationsResponse>.volumesModifications(): Flow<VolumeModification> =
    transform() { response ->
        response.volumesModifications?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVolumeStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVolumeStatusRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumeStatusResponse]
 */
public fun Ec2Client.describeVolumeStatusPaginated(initialRequest: DescribeVolumeStatusRequest): Flow<DescribeVolumeStatusResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVolumeStatusPaginated.describeVolumeStatus(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVolumeStatusResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVolumeStatusResponse]
 */
public fun Ec2Client.describeVolumeStatusPaginated(block: DescribeVolumeStatusRequest.Builder.() -> Unit): Flow<DescribeVolumeStatusResponse> =
    describeVolumeStatusPaginated(DescribeVolumeStatusRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVolumeStatusPaginated]
 * to access the nested member [VolumeStatusItem]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VolumeStatusItem]
 */
@JvmName("describeVolumeStatusResponseVolumeStatusItem")
public fun Flow<DescribeVolumeStatusResponse>.volumeStatuses(): Flow<VolumeStatusItem> =
    transform() { response ->
        response.volumeStatuses?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcClassicLinkDnsSupportResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcClassicLinkDnsSupportRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcClassicLinkDnsSupportResponse]
 */
public fun Ec2Client.describeVpcClassicLinkDnsSupportPaginated(initialRequest: DescribeVpcClassicLinkDnsSupportRequest): Flow<DescribeVpcClassicLinkDnsSupportResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcClassicLinkDnsSupportPaginated.describeVpcClassicLinkDnsSupport(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcClassicLinkDnsSupportResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcClassicLinkDnsSupportResponse]
 */
public fun Ec2Client.describeVpcClassicLinkDnsSupportPaginated(block: DescribeVpcClassicLinkDnsSupportRequest.Builder.() -> Unit): Flow<DescribeVpcClassicLinkDnsSupportResponse> =
    describeVpcClassicLinkDnsSupportPaginated(DescribeVpcClassicLinkDnsSupportRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcClassicLinkDnsSupportPaginated]
 * to access the nested member [ClassicLinkDnsSupport]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ClassicLinkDnsSupport]
 */
@JvmName("describeVpcClassicLinkDnsSupportResponseClassicLinkDnsSupport")
public fun Flow<DescribeVpcClassicLinkDnsSupportResponse>.vpcs(): Flow<ClassicLinkDnsSupport> =
    transform() { response ->
        response.vpcs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionNotificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcEndpointConnectionNotificationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionNotificationsResponse]
 */
public fun Ec2Client.describeVpcEndpointConnectionNotificationsPaginated(initialRequest: DescribeVpcEndpointConnectionNotificationsRequest): Flow<DescribeVpcEndpointConnectionNotificationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointConnectionNotificationsPaginated.describeVpcEndpointConnectionNotifications(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionNotificationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionNotificationsResponse]
 */
public fun Ec2Client.describeVpcEndpointConnectionNotificationsPaginated(block: DescribeVpcEndpointConnectionNotificationsRequest.Builder.() -> Unit): Flow<DescribeVpcEndpointConnectionNotificationsResponse> =
    describeVpcEndpointConnectionNotificationsPaginated(DescribeVpcEndpointConnectionNotificationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcEndpointConnectionNotificationsPaginated]
 * to access the nested member [ConnectionNotification]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ConnectionNotification]
 */
@JvmName("describeVpcEndpointConnectionNotificationsResponseConnectionNotification")
public fun Flow<DescribeVpcEndpointConnectionNotificationsResponse>.connectionNotificationSet(): Flow<ConnectionNotification> =
    transform() { response ->
        response.connectionNotificationSet?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcEndpointConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionsResponse]
 */
public fun Ec2Client.describeVpcEndpointConnectionsPaginated(initialRequest: DescribeVpcEndpointConnectionsRequest): Flow<DescribeVpcEndpointConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointConnectionsPaginated.describeVpcEndpointConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointConnectionsResponse]
 */
public fun Ec2Client.describeVpcEndpointConnectionsPaginated(block: DescribeVpcEndpointConnectionsRequest.Builder.() -> Unit): Flow<DescribeVpcEndpointConnectionsResponse> =
    describeVpcEndpointConnectionsPaginated(DescribeVpcEndpointConnectionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcEndpointConnectionsPaginated]
 * to access the nested member [VpcEndpointConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcEndpointConnection]
 */
@JvmName("describeVpcEndpointConnectionsResponseVpcEndpointConnection")
public fun Flow<DescribeVpcEndpointConnectionsResponse>.vpcEndpointConnections(): Flow<VpcEndpointConnection> =
    transform() { response ->
        response.vpcEndpointConnections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcEndpointsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointsResponse]
 */
public fun Ec2Client.describeVpcEndpointsPaginated(initialRequest: DescribeVpcEndpointsRequest): Flow<DescribeVpcEndpointsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointsPaginated.describeVpcEndpoints(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointsResponse]
 */
public fun Ec2Client.describeVpcEndpointsPaginated(block: DescribeVpcEndpointsRequest.Builder.() -> Unit): Flow<DescribeVpcEndpointsResponse> =
    describeVpcEndpointsPaginated(DescribeVpcEndpointsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcEndpointsPaginated]
 * to access the nested member [VpcEndpoint]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcEndpoint]
 */
@JvmName("describeVpcEndpointsResponseVpcEndpoint")
public fun Flow<DescribeVpcEndpointsResponse>.vpcEndpoints(): Flow<VpcEndpoint> =
    transform() { response ->
        response.vpcEndpoints?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServiceConfigurationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcEndpointServiceConfigurationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServiceConfigurationsResponse]
 */
public fun Ec2Client.describeVpcEndpointServiceConfigurationsPaginated(initialRequest: DescribeVpcEndpointServiceConfigurationsRequest): Flow<DescribeVpcEndpointServiceConfigurationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointServiceConfigurationsPaginated.describeVpcEndpointServiceConfigurations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServiceConfigurationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServiceConfigurationsResponse]
 */
public fun Ec2Client.describeVpcEndpointServiceConfigurationsPaginated(block: DescribeVpcEndpointServiceConfigurationsRequest.Builder.() -> Unit): Flow<DescribeVpcEndpointServiceConfigurationsResponse> =
    describeVpcEndpointServiceConfigurationsPaginated(DescribeVpcEndpointServiceConfigurationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcEndpointServiceConfigurationsPaginated]
 * to access the nested member [ServiceConfiguration]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ServiceConfiguration]
 */
@JvmName("describeVpcEndpointServiceConfigurationsResponseServiceConfiguration")
public fun Flow<DescribeVpcEndpointServiceConfigurationsResponse>.serviceConfigurations(): Flow<ServiceConfiguration> =
    transform() { response ->
        response.serviceConfigurations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServicePermissionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcEndpointServicePermissionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServicePermissionsResponse]
 */
public fun Ec2Client.describeVpcEndpointServicePermissionsPaginated(initialRequest: DescribeVpcEndpointServicePermissionsRequest): Flow<DescribeVpcEndpointServicePermissionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcEndpointServicePermissionsPaginated.describeVpcEndpointServicePermissions(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcEndpointServicePermissionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcEndpointServicePermissionsResponse]
 */
public fun Ec2Client.describeVpcEndpointServicePermissionsPaginated(block: DescribeVpcEndpointServicePermissionsRequest.Builder.() -> Unit): Flow<DescribeVpcEndpointServicePermissionsResponse> =
    describeVpcEndpointServicePermissionsPaginated(DescribeVpcEndpointServicePermissionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcEndpointServicePermissionsPaginated]
 * to access the nested member [AllowedPrincipal]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [AllowedPrincipal]
 */
@JvmName("describeVpcEndpointServicePermissionsResponseAllowedPrincipal")
public fun Flow<DescribeVpcEndpointServicePermissionsResponse>.allowedPrincipals(): Flow<AllowedPrincipal> =
    transform() { response ->
        response.allowedPrincipals?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcPeeringConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcPeeringConnectionsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcPeeringConnectionsResponse]
 */
public fun Ec2Client.describeVpcPeeringConnectionsPaginated(initialRequest: DescribeVpcPeeringConnectionsRequest): Flow<DescribeVpcPeeringConnectionsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcPeeringConnectionsPaginated.describeVpcPeeringConnections(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcPeeringConnectionsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcPeeringConnectionsResponse]
 */
public fun Ec2Client.describeVpcPeeringConnectionsPaginated(block: DescribeVpcPeeringConnectionsRequest.Builder.() -> Unit): Flow<DescribeVpcPeeringConnectionsResponse> =
    describeVpcPeeringConnectionsPaginated(DescribeVpcPeeringConnectionsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcPeeringConnectionsPaginated]
 * to access the nested member [VpcPeeringConnection]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpcPeeringConnection]
 */
@JvmName("describeVpcPeeringConnectionsResponseVpcPeeringConnection")
public fun Flow<DescribeVpcPeeringConnectionsResponse>.vpcPeeringConnections(): Flow<VpcPeeringConnection> =
    transform() { response ->
        response.vpcPeeringConnections?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [DescribeVpcsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [DescribeVpcsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcsResponse]
 */
public fun Ec2Client.describeVpcsPaginated(initialRequest: DescribeVpcsRequest): Flow<DescribeVpcsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@describeVpcsPaginated.describeVpcs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [DescribeVpcsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [DescribeVpcsResponse]
 */
public fun Ec2Client.describeVpcsPaginated(block: DescribeVpcsRequest.Builder.() -> Unit): Flow<DescribeVpcsResponse> =
    describeVpcsPaginated(DescribeVpcsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [describeVpcsPaginated]
 * to access the nested member [Vpc]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Vpc]
 */
@JvmName("describeVpcsResponseVpc")
public fun Flow<DescribeVpcsResponse>.vpcs(): Flow<Vpc> =
    transform() { response ->
        response.vpcs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetAssociatedIpv6PoolCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetAssociatedIpv6PoolCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetAssociatedIpv6PoolCidrsResponse]
 */
public fun Ec2Client.getAssociatedIpv6PoolCidrsPaginated(initialRequest: GetAssociatedIpv6PoolCidrsRequest): Flow<GetAssociatedIpv6PoolCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getAssociatedIpv6PoolCidrsPaginated.getAssociatedIpv6PoolCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetAssociatedIpv6PoolCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetAssociatedIpv6PoolCidrsResponse]
 */
public fun Ec2Client.getAssociatedIpv6PoolCidrsPaginated(block: GetAssociatedIpv6PoolCidrsRequest.Builder.() -> Unit): Flow<GetAssociatedIpv6PoolCidrsResponse> =
    getAssociatedIpv6PoolCidrsPaginated(GetAssociatedIpv6PoolCidrsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getAssociatedIpv6PoolCidrsPaginated]
 * to access the nested member [Ipv6CidrAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [Ipv6CidrAssociation]
 */
@JvmName("getAssociatedIpv6PoolCidrsResponseIpv6CidrAssociation")
public fun Flow<GetAssociatedIpv6PoolCidrsResponse>.ipv6CidrAssociations(): Flow<Ipv6CidrAssociation> =
    transform() { response ->
        response.ipv6CidrAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetGroupsForCapacityReservationResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetGroupsForCapacityReservationRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetGroupsForCapacityReservationResponse]
 */
public fun Ec2Client.getGroupsForCapacityReservationPaginated(initialRequest: GetGroupsForCapacityReservationRequest): Flow<GetGroupsForCapacityReservationResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getGroupsForCapacityReservationPaginated.getGroupsForCapacityReservation(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetGroupsForCapacityReservationResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetGroupsForCapacityReservationResponse]
 */
public fun Ec2Client.getGroupsForCapacityReservationPaginated(block: GetGroupsForCapacityReservationRequest.Builder.() -> Unit): Flow<GetGroupsForCapacityReservationResponse> =
    getGroupsForCapacityReservationPaginated(GetGroupsForCapacityReservationRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getGroupsForCapacityReservationPaginated]
 * to access the nested member [CapacityReservationGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [CapacityReservationGroup]
 */
@JvmName("getGroupsForCapacityReservationResponseCapacityReservationGroup")
public fun Flow<GetGroupsForCapacityReservationResponse>.capacityReservationGroups(): Flow<CapacityReservationGroup> =
    transform() { response ->
        response.capacityReservationGroups?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetInstanceTypesFromInstanceRequirementsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetInstanceTypesFromInstanceRequirementsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetInstanceTypesFromInstanceRequirementsResponse]
 */
public fun Ec2Client.getInstanceTypesFromInstanceRequirementsPaginated(initialRequest: GetInstanceTypesFromInstanceRequirementsRequest): Flow<GetInstanceTypesFromInstanceRequirementsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getInstanceTypesFromInstanceRequirementsPaginated.getInstanceTypesFromInstanceRequirements(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetInstanceTypesFromInstanceRequirementsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetInstanceTypesFromInstanceRequirementsResponse]
 */
public fun Ec2Client.getInstanceTypesFromInstanceRequirementsPaginated(block: GetInstanceTypesFromInstanceRequirementsRequest.Builder.() -> Unit): Flow<GetInstanceTypesFromInstanceRequirementsResponse> =
    getInstanceTypesFromInstanceRequirementsPaginated(GetInstanceTypesFromInstanceRequirementsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getInstanceTypesFromInstanceRequirementsPaginated]
 * to access the nested member [InstanceTypeInfoFromInstanceRequirements]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [InstanceTypeInfoFromInstanceRequirements]
 */
@JvmName("getInstanceTypesFromInstanceRequirementsResponseInstanceTypeInfoFromInstanceRequirements")
public fun Flow<GetInstanceTypesFromInstanceRequirementsResponse>.instanceTypes(): Flow<InstanceTypeInfoFromInstanceRequirements> =
    transform() { response ->
        response.instanceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamAddressHistoryResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetIpamAddressHistoryRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamAddressHistoryResponse]
 */
public fun Ec2Client.getIpamAddressHistoryPaginated(initialRequest: GetIpamAddressHistoryRequest): Flow<GetIpamAddressHistoryResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamAddressHistoryPaginated.getIpamAddressHistory(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetIpamAddressHistoryResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamAddressHistoryResponse]
 */
public fun Ec2Client.getIpamAddressHistoryPaginated(block: GetIpamAddressHistoryRequest.Builder.() -> Unit): Flow<GetIpamAddressHistoryResponse> =
    getIpamAddressHistoryPaginated(GetIpamAddressHistoryRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getIpamAddressHistoryPaginated]
 * to access the nested member [IpamAddressHistoryRecord]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamAddressHistoryRecord]
 */
@JvmName("getIpamAddressHistoryResponseIpamAddressHistoryRecord")
public fun Flow<GetIpamAddressHistoryResponse>.historyRecords(): Flow<IpamAddressHistoryRecord> =
    transform() { response ->
        response.historyRecords?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamPoolAllocationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetIpamPoolAllocationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolAllocationsResponse]
 */
public fun Ec2Client.getIpamPoolAllocationsPaginated(initialRequest: GetIpamPoolAllocationsRequest): Flow<GetIpamPoolAllocationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamPoolAllocationsPaginated.getIpamPoolAllocations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetIpamPoolAllocationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolAllocationsResponse]
 */
public fun Ec2Client.getIpamPoolAllocationsPaginated(block: GetIpamPoolAllocationsRequest.Builder.() -> Unit): Flow<GetIpamPoolAllocationsResponse> =
    getIpamPoolAllocationsPaginated(GetIpamPoolAllocationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getIpamPoolAllocationsPaginated]
 * to access the nested member [IpamPoolAllocation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPoolAllocation]
 */
@JvmName("getIpamPoolAllocationsResponseIpamPoolAllocation")
public fun Flow<GetIpamPoolAllocationsResponse>.ipamPoolAllocations(): Flow<IpamPoolAllocation> =
    transform() { response ->
        response.ipamPoolAllocations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamPoolCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetIpamPoolCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolCidrsResponse]
 */
public fun Ec2Client.getIpamPoolCidrsPaginated(initialRequest: GetIpamPoolCidrsRequest): Flow<GetIpamPoolCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamPoolCidrsPaginated.getIpamPoolCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetIpamPoolCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamPoolCidrsResponse]
 */
public fun Ec2Client.getIpamPoolCidrsPaginated(block: GetIpamPoolCidrsRequest.Builder.() -> Unit): Flow<GetIpamPoolCidrsResponse> =
    getIpamPoolCidrsPaginated(GetIpamPoolCidrsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getIpamPoolCidrsPaginated]
 * to access the nested member [IpamPoolCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamPoolCidr]
 */
@JvmName("getIpamPoolCidrsResponseIpamPoolCidr")
public fun Flow<GetIpamPoolCidrsResponse>.ipamPoolCidrs(): Flow<IpamPoolCidr> =
    transform() { response ->
        response.ipamPoolCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetIpamResourceCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetIpamResourceCidrsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamResourceCidrsResponse]
 */
public fun Ec2Client.getIpamResourceCidrsPaginated(initialRequest: GetIpamResourceCidrsRequest): Flow<GetIpamResourceCidrsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getIpamResourceCidrsPaginated.getIpamResourceCidrs(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetIpamResourceCidrsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetIpamResourceCidrsResponse]
 */
public fun Ec2Client.getIpamResourceCidrsPaginated(block: GetIpamResourceCidrsRequest.Builder.() -> Unit): Flow<GetIpamResourceCidrsResponse> =
    getIpamResourceCidrsPaginated(GetIpamResourceCidrsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getIpamResourceCidrsPaginated]
 * to access the nested member [IpamResourceCidr]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [IpamResourceCidr]
 */
@JvmName("getIpamResourceCidrsResponseIpamResourceCidr")
public fun Flow<GetIpamResourceCidrsResponse>.ipamResourceCidrs(): Flow<IpamResourceCidr> =
    transform() { response ->
        response.ipamResourceCidrs?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetManagedPrefixListAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetManagedPrefixListAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListAssociationsResponse]
 */
public fun Ec2Client.getManagedPrefixListAssociationsPaginated(initialRequest: GetManagedPrefixListAssociationsRequest): Flow<GetManagedPrefixListAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getManagedPrefixListAssociationsPaginated.getManagedPrefixListAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetManagedPrefixListAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListAssociationsResponse]
 */
public fun Ec2Client.getManagedPrefixListAssociationsPaginated(block: GetManagedPrefixListAssociationsRequest.Builder.() -> Unit): Flow<GetManagedPrefixListAssociationsResponse> =
    getManagedPrefixListAssociationsPaginated(GetManagedPrefixListAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getManagedPrefixListAssociationsPaginated]
 * to access the nested member [PrefixListAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixListAssociation]
 */
@JvmName("getManagedPrefixListAssociationsResponsePrefixListAssociation")
public fun Flow<GetManagedPrefixListAssociationsResponse>.prefixListAssociations(): Flow<PrefixListAssociation> =
    transform() { response ->
        response.prefixListAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetManagedPrefixListEntriesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetManagedPrefixListEntriesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListEntriesResponse]
 */
public fun Ec2Client.getManagedPrefixListEntriesPaginated(initialRequest: GetManagedPrefixListEntriesRequest): Flow<GetManagedPrefixListEntriesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getManagedPrefixListEntriesPaginated.getManagedPrefixListEntries(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetManagedPrefixListEntriesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetManagedPrefixListEntriesResponse]
 */
public fun Ec2Client.getManagedPrefixListEntriesPaginated(block: GetManagedPrefixListEntriesRequest.Builder.() -> Unit): Flow<GetManagedPrefixListEntriesResponse> =
    getManagedPrefixListEntriesPaginated(GetManagedPrefixListEntriesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getManagedPrefixListEntriesPaginated]
 * to access the nested member [PrefixListEntry]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [PrefixListEntry]
 */
@JvmName("getManagedPrefixListEntriesResponsePrefixListEntry")
public fun Flow<GetManagedPrefixListEntriesResponse>.entries(): Flow<PrefixListEntry> =
    transform() { response ->
        response.entries?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetSpotPlacementScoresResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetSpotPlacementScoresRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetSpotPlacementScoresResponse]
 */
public fun Ec2Client.getSpotPlacementScoresPaginated(initialRequest: GetSpotPlacementScoresRequest): Flow<GetSpotPlacementScoresResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getSpotPlacementScoresPaginated.getSpotPlacementScores(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetSpotPlacementScoresResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetSpotPlacementScoresResponse]
 */
public fun Ec2Client.getSpotPlacementScoresPaginated(block: GetSpotPlacementScoresRequest.Builder.() -> Unit): Flow<GetSpotPlacementScoresResponse> =
    getSpotPlacementScoresPaginated(GetSpotPlacementScoresRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getSpotPlacementScoresPaginated]
 * to access the nested member [SpotPlacementScore]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SpotPlacementScore]
 */
@JvmName("getSpotPlacementScoresResponseSpotPlacementScore")
public fun Flow<GetSpotPlacementScoresResponse>.spotPlacementScores(): Flow<SpotPlacementScore> =
    transform() { response ->
        response.spotPlacementScores?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayAttachmentPropagationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayAttachmentPropagationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayAttachmentPropagationsResponse]
 */
public fun Ec2Client.getTransitGatewayAttachmentPropagationsPaginated(initialRequest: GetTransitGatewayAttachmentPropagationsRequest): Flow<GetTransitGatewayAttachmentPropagationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayAttachmentPropagationsPaginated.getTransitGatewayAttachmentPropagations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayAttachmentPropagationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayAttachmentPropagationsResponse]
 */
public fun Ec2Client.getTransitGatewayAttachmentPropagationsPaginated(block: GetTransitGatewayAttachmentPropagationsRequest.Builder.() -> Unit): Flow<GetTransitGatewayAttachmentPropagationsResponse> =
    getTransitGatewayAttachmentPropagationsPaginated(GetTransitGatewayAttachmentPropagationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayAttachmentPropagationsPaginated]
 * to access the nested member [TransitGatewayAttachmentPropagation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayAttachmentPropagation]
 */
@JvmName("getTransitGatewayAttachmentPropagationsResponseTransitGatewayAttachmentPropagation")
public fun Flow<GetTransitGatewayAttachmentPropagationsResponse>.transitGatewayAttachmentPropagations(): Flow<TransitGatewayAttachmentPropagation> =
    transform() { response ->
        response.transitGatewayAttachmentPropagations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayMulticastDomainAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayMulticastDomainAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayMulticastDomainAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayMulticastDomainAssociationsPaginated(initialRequest: GetTransitGatewayMulticastDomainAssociationsRequest): Flow<GetTransitGatewayMulticastDomainAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayMulticastDomainAssociationsPaginated.getTransitGatewayMulticastDomainAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayMulticastDomainAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayMulticastDomainAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayMulticastDomainAssociationsPaginated(block: GetTransitGatewayMulticastDomainAssociationsRequest.Builder.() -> Unit): Flow<GetTransitGatewayMulticastDomainAssociationsResponse> =
    getTransitGatewayMulticastDomainAssociationsPaginated(GetTransitGatewayMulticastDomainAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayMulticastDomainAssociationsPaginated]
 * to access the nested member [TransitGatewayMulticastDomainAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastDomainAssociation]
 */
@JvmName("getTransitGatewayMulticastDomainAssociationsResponseTransitGatewayMulticastDomainAssociation")
public fun Flow<GetTransitGatewayMulticastDomainAssociationsResponse>.multicastDomainAssociations(): Flow<TransitGatewayMulticastDomainAssociation> =
    transform() { response ->
        response.multicastDomainAssociations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayPolicyTableAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayPolicyTableAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayPolicyTableAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayPolicyTableAssociationsPaginated(initialRequest: GetTransitGatewayPolicyTableAssociationsRequest): Flow<GetTransitGatewayPolicyTableAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayPolicyTableAssociationsPaginated.getTransitGatewayPolicyTableAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayPolicyTableAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayPolicyTableAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayPolicyTableAssociationsPaginated(block: GetTransitGatewayPolicyTableAssociationsRequest.Builder.() -> Unit): Flow<GetTransitGatewayPolicyTableAssociationsResponse> =
    getTransitGatewayPolicyTableAssociationsPaginated(GetTransitGatewayPolicyTableAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayPolicyTableAssociationsPaginated]
 * to access the nested member [TransitGatewayPolicyTableAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPolicyTableAssociation]
 */
@JvmName("getTransitGatewayPolicyTableAssociationsResponseTransitGatewayPolicyTableAssociation")
public fun Flow<GetTransitGatewayPolicyTableAssociationsResponse>.associations(): Flow<TransitGatewayPolicyTableAssociation> =
    transform() { response ->
        response.associations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayPrefixListReferencesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayPrefixListReferencesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayPrefixListReferencesResponse]
 */
public fun Ec2Client.getTransitGatewayPrefixListReferencesPaginated(initialRequest: GetTransitGatewayPrefixListReferencesRequest): Flow<GetTransitGatewayPrefixListReferencesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayPrefixListReferencesPaginated.getTransitGatewayPrefixListReferences(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayPrefixListReferencesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayPrefixListReferencesResponse]
 */
public fun Ec2Client.getTransitGatewayPrefixListReferencesPaginated(block: GetTransitGatewayPrefixListReferencesRequest.Builder.() -> Unit): Flow<GetTransitGatewayPrefixListReferencesResponse> =
    getTransitGatewayPrefixListReferencesPaginated(GetTransitGatewayPrefixListReferencesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayPrefixListReferencesPaginated]
 * to access the nested member [TransitGatewayPrefixListReference]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayPrefixListReference]
 */
@JvmName("getTransitGatewayPrefixListReferencesResponseTransitGatewayPrefixListReference")
public fun Flow<GetTransitGatewayPrefixListReferencesResponse>.transitGatewayPrefixListReferences(): Flow<TransitGatewayPrefixListReference> =
    transform() { response ->
        response.transitGatewayPrefixListReferences?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTableAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayRouteTableAssociationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTableAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayRouteTableAssociationsPaginated(initialRequest: GetTransitGatewayRouteTableAssociationsRequest): Flow<GetTransitGatewayRouteTableAssociationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayRouteTableAssociationsPaginated.getTransitGatewayRouteTableAssociations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTableAssociationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTableAssociationsResponse]
 */
public fun Ec2Client.getTransitGatewayRouteTableAssociationsPaginated(block: GetTransitGatewayRouteTableAssociationsRequest.Builder.() -> Unit): Flow<GetTransitGatewayRouteTableAssociationsResponse> =
    getTransitGatewayRouteTableAssociationsPaginated(GetTransitGatewayRouteTableAssociationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayRouteTableAssociationsPaginated]
 * to access the nested member [TransitGatewayRouteTableAssociation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTableAssociation]
 */
@JvmName("getTransitGatewayRouteTableAssociationsResponseTransitGatewayRouteTableAssociation")
public fun Flow<GetTransitGatewayRouteTableAssociationsResponse>.associations(): Flow<TransitGatewayRouteTableAssociation> =
    transform() { response ->
        response.associations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTablePropagationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetTransitGatewayRouteTablePropagationsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTablePropagationsResponse]
 */
public fun Ec2Client.getTransitGatewayRouteTablePropagationsPaginated(initialRequest: GetTransitGatewayRouteTablePropagationsRequest): Flow<GetTransitGatewayRouteTablePropagationsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getTransitGatewayRouteTablePropagationsPaginated.getTransitGatewayRouteTablePropagations(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetTransitGatewayRouteTablePropagationsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetTransitGatewayRouteTablePropagationsResponse]
 */
public fun Ec2Client.getTransitGatewayRouteTablePropagationsPaginated(block: GetTransitGatewayRouteTablePropagationsRequest.Builder.() -> Unit): Flow<GetTransitGatewayRouteTablePropagationsResponse> =
    getTransitGatewayRouteTablePropagationsPaginated(GetTransitGatewayRouteTablePropagationsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getTransitGatewayRouteTablePropagationsPaginated]
 * to access the nested member [TransitGatewayRouteTablePropagation]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayRouteTablePropagation]
 */
@JvmName("getTransitGatewayRouteTablePropagationsResponseTransitGatewayRouteTablePropagation")
public fun Flow<GetTransitGatewayRouteTablePropagationsResponse>.transitGatewayRouteTablePropagations(): Flow<TransitGatewayRouteTablePropagation> =
    transform() { response ->
        response.transitGatewayRouteTablePropagations?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [GetVpnConnectionDeviceTypesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [GetVpnConnectionDeviceTypesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetVpnConnectionDeviceTypesResponse]
 */
public fun Ec2Client.getVpnConnectionDeviceTypesPaginated(initialRequest: GetVpnConnectionDeviceTypesRequest): Flow<GetVpnConnectionDeviceTypesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@getVpnConnectionDeviceTypesPaginated.getVpnConnectionDeviceTypes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [GetVpnConnectionDeviceTypesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [GetVpnConnectionDeviceTypesResponse]
 */
public fun Ec2Client.getVpnConnectionDeviceTypesPaginated(block: GetVpnConnectionDeviceTypesRequest.Builder.() -> Unit): Flow<GetVpnConnectionDeviceTypesResponse> =
    getVpnConnectionDeviceTypesPaginated(GetVpnConnectionDeviceTypesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [getVpnConnectionDeviceTypesPaginated]
 * to access the nested member [VpnConnectionDeviceType]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [VpnConnectionDeviceType]
 */
@JvmName("getVpnConnectionDeviceTypesResponseVpnConnectionDeviceType")
public fun Flow<GetVpnConnectionDeviceTypesResponse>.vpnConnectionDeviceTypes(): Flow<VpnConnectionDeviceType> =
    transform() { response ->
        response.vpnConnectionDeviceTypes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [ListImagesInRecycleBinResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [ListImagesInRecycleBinRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ListImagesInRecycleBinResponse]
 */
public fun Ec2Client.listImagesInRecycleBinPaginated(initialRequest: ListImagesInRecycleBinRequest): Flow<ListImagesInRecycleBinResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@listImagesInRecycleBinPaginated.listImagesInRecycleBin(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [ListImagesInRecycleBinResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ListImagesInRecycleBinResponse]
 */
public fun Ec2Client.listImagesInRecycleBinPaginated(block: ListImagesInRecycleBinRequest.Builder.() -> Unit): Flow<ListImagesInRecycleBinResponse> =
    listImagesInRecycleBinPaginated(ListImagesInRecycleBinRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [listImagesInRecycleBinPaginated]
 * to access the nested member [ImageRecycleBinInfo]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ImageRecycleBinInfo]
 */
@JvmName("listImagesInRecycleBinResponseImageRecycleBinInfo")
public fun Flow<ListImagesInRecycleBinResponse>.images(): Flow<ImageRecycleBinInfo> =
    transform() { response ->
        response.images?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [ListSnapshotsInRecycleBinResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [ListSnapshotsInRecycleBinRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ListSnapshotsInRecycleBinResponse]
 */
public fun Ec2Client.listSnapshotsInRecycleBinPaginated(initialRequest: ListSnapshotsInRecycleBinRequest): Flow<ListSnapshotsInRecycleBinResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@listSnapshotsInRecycleBinPaginated.listSnapshotsInRecycleBin(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [ListSnapshotsInRecycleBinResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [ListSnapshotsInRecycleBinResponse]
 */
public fun Ec2Client.listSnapshotsInRecycleBinPaginated(block: ListSnapshotsInRecycleBinRequest.Builder.() -> Unit): Flow<ListSnapshotsInRecycleBinResponse> =
    listSnapshotsInRecycleBinPaginated(ListSnapshotsInRecycleBinRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [listSnapshotsInRecycleBinPaginated]
 * to access the nested member [SnapshotRecycleBinInfo]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SnapshotRecycleBinInfo]
 */
@JvmName("listSnapshotsInRecycleBinResponseSnapshotRecycleBinInfo")
public fun Flow<ListSnapshotsInRecycleBinResponse>.snapshots(): Flow<SnapshotRecycleBinInfo> =
    transform() { response ->
        response.snapshots?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [SearchLocalGatewayRoutesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [SearchLocalGatewayRoutesRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchLocalGatewayRoutesResponse]
 */
public fun Ec2Client.searchLocalGatewayRoutesPaginated(initialRequest: SearchLocalGatewayRoutesRequest): Flow<SearchLocalGatewayRoutesResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@searchLocalGatewayRoutesPaginated.searchLocalGatewayRoutes(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [SearchLocalGatewayRoutesResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchLocalGatewayRoutesResponse]
 */
public fun Ec2Client.searchLocalGatewayRoutesPaginated(block: SearchLocalGatewayRoutesRequest.Builder.() -> Unit): Flow<SearchLocalGatewayRoutesResponse> =
    searchLocalGatewayRoutesPaginated(SearchLocalGatewayRoutesRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [searchLocalGatewayRoutesPaginated]
 * to access the nested member [LocalGatewayRoute]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [LocalGatewayRoute]
 */
@JvmName("searchLocalGatewayRoutesResponseLocalGatewayRoute")
public fun Flow<SearchLocalGatewayRoutesResponse>.routes(): Flow<LocalGatewayRoute> =
    transform() { response ->
        response.routes?.forEach {
            emit(it)
        }
    }

/**
 * Paginate over [SearchTransitGatewayMulticastGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param initialRequest A [SearchTransitGatewayMulticastGroupsRequest] to start pagination
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchTransitGatewayMulticastGroupsResponse]
 */
public fun Ec2Client.searchTransitGatewayMulticastGroupsPaginated(initialRequest: SearchTransitGatewayMulticastGroupsRequest): Flow<SearchTransitGatewayMulticastGroupsResponse> =
    flow {
        var cursor: kotlin.String? = null
        var isFirstPage: Boolean = true

        while (isFirstPage || (cursor?.isNotEmpty() == true)) {
            val req = initialRequest.copy {
                this.nextToken = cursor
            }
            val result = this@searchTransitGatewayMulticastGroupsPaginated.searchTransitGatewayMulticastGroups(req)
            isFirstPage = false
            cursor = result.nextToken
            emit(result)
        }
    }

/**
 * Paginate over [SearchTransitGatewayMulticastGroupsResponse] results.
 *
 * When this operation is called, a [kotlinx.coroutines.Flow] is created. Flows are lazy (cold) so no service
 * calls are made until the flow is collected. This also means there is no guarantee that the request is valid
 * until then. Once you start collecting the flow, the SDK will lazily load response pages by making service
 * calls until there are no pages left or the flow is cancelled. If there are errors in your request, you will
 * see the failures only after you start collection.
 * @param block A builder block used for DSL-style invocation of the operation
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [SearchTransitGatewayMulticastGroupsResponse]
 */
public fun Ec2Client.searchTransitGatewayMulticastGroupsPaginated(block: SearchTransitGatewayMulticastGroupsRequest.Builder.() -> Unit): Flow<SearchTransitGatewayMulticastGroupsResponse> =
    searchTransitGatewayMulticastGroupsPaginated(SearchTransitGatewayMulticastGroupsRequest.Builder().apply(block).build())

/**
 * This paginator transforms the flow returned by [searchTransitGatewayMulticastGroupsPaginated]
 * to access the nested member [TransitGatewayMulticastGroup]
 * @return A [kotlinx.coroutines.flow.Flow] that can collect [TransitGatewayMulticastGroup]
 */
@JvmName("searchTransitGatewayMulticastGroupsResponseTransitGatewayMulticastGroup")
public fun Flow<SearchTransitGatewayMulticastGroupsResponse>.multicastGroups(): Flow<TransitGatewayMulticastGroup> =
    transform() { response ->
        response.multicastGroups?.forEach {
            emit(it)
        }
    }
